---
title: "Trait Selection"
author: Anna L Tyler
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: hide
    collapsed: no
    toc: yes
    toc_float: yes
---

## Introduction
This workflow selects traits for use in high-dimensional mediation.
The final product is a trait matrix that is used in downstream analyses.

```{r load_code}
is.interactive = FALSE
#is.interactive = TRUE

rm(list = ls())

library("here")

parsed.data.dir <- here("Results", "DO", "Data") #a results folder that holds parsed data that we don't want to mix in with downloaded data
if(!file.exists(parsed.data.dir)){dir.create(parsed.data.dir, recursive = TRUE)}

paper.data.dir <- here("Results", "Paper") #for results that will be used in the manuscript
if(!file.exists(paper.data.dir)){dir.create(paper.data.dir, recursive = TRUE)}
paper.data <- list("paper.data" = list(), "data.idx" = 1)

figure.data.dir <- here("Results", "Paper", "Source_Data") #Nature Communications requires data for all figures. Keep it here
if(!file.exists(figure.data.dir)){dir.create(figure.data.dir, recursive = TRUE)}

all.fun <- list.files(here("Code"), full.names = TRUE, pattern = ".R")
for(i in 1:length(all.fun)){source(all.fun[i])}
```

```{r load_libraries, message = FALSE, warning = FALSE, error = FALSE}
all.packages <- c("pheatmap", "cluster", "igraph")

load_libraries(all.packages)
```

```{r record_result_fun}
#This function collects results in a big list
#that can be written to one file and saved for 
#use in the manuscript
record_result <- function(the.result, data.list, data.label, data.idx){
  data.list[[data.idx]] <- the.result
  names(data.list)[data.idx] <- data.label
  data.idx <- data.idx + 1
  return(list("paper.data" = data.list, "data.idx" = data.idx))
}
```

```{r cutoffs}
#diabetic range from PMID
glucose.ranges <- c(250, 300) 
paper.data <- record_result(glucose.ranges, paper.data$paper.data, "glucose_ranges", paper.data$data.idx)
```

## Data

Data were generated through a collaboration between the Attie
lab at the University of Wisconsin, and The Jackson Laboratory
Detailed descriptions of mouse handling, phenotype gathering,
and initial data processing can be found elsewhere. 

Here we focus exclusively on the clinical phenotoype data.

## Read phenotypes

In the following sections, we take a look at some of 
the individual data points to look for oddities.

```{r pheno}
pheno.data <- readRDS(here("Data", "DO", "Clinical_Phenotypes_V11.RDS"))
#write out annotations for phenotypes
write.table(pheno.data$annot.phenotype, file.path(parsed.data.dir, "Phenotype_Annotations.txt"), 
  sep = "\t", quote = FALSE, row.names = FALSE)

num.pheno <- pheno.data$data
#fix the spelling of adiposity
colnames(num.pheno)[which(colnames(num.pheno) == "adipocity")] <- "adiposity"

covar <- as.matrix(pheno.data$annot.samples[,c("Sex", "Wave", "Generation")])
num.covar <- dummy_covar(covar)
rownames(num.covar) <- rownames(num.pheno)
saveRDS(num.covar, file.path(parsed.data.dir, "Clinical_Phenotype_Covariates.RDS"))

```

## Body Weight

Investigate body weight patterns.
The following boxplot shows two wicked outliers that 
are definitely mistakes. I am removing the point in 
week 11 that is 200 grams, and the other in week 17 
that is 5 grams. 

```{r bw}
weight.idx <- grep("weight", colnames(num.pheno))
#remove organ weights
organ.idx <- sapply(c("heart", "liver", "fat"), function(x) grep(x, colnames(num.pheno)))
bw.idx <- setdiff(weight.idx, organ.idx)
bw <- num.pheno[,bw.idx]
ordered.bw  <- cbind(bw[,-1], bw[,1,drop=FALSE])
boxplot(ordered.bw, las = 2)
```

The following boxplot shows the corrected weights

```{r remove_obvious_errors}
outlier1 <- which(ordered.bw > 100)
ordered.bw[outlier1] <- NA

outlier2 <- which(ordered.bw < 6)
ordered.bw[outlier2] <- NA
boxplot(ordered.bw, las = 2)
```

There is really one axis of variation in the weight
matrix that corresponds very highly with the final 
weight. The following barplot shows the variance
explained by the PCs of the weight matrix. 

```{r weight_decomp, warning = FALSE}
bw.decomp <- plot.decomp(ordered.bw, plot.results = FALSE)
barplot_with_num(round(bw.decomp$var.exp, 2), main = "Variance Explained",
  text.srt = 45)
```

The following plot shows the high concordance between the first 
PC of the weight matrix and the final weight. Thus, I think we
can safely use final weight as the only weight measurement
without losing any important information.

```{r weight_pc}
avg.weight <- apply(ordered.bw, 1, function(x) mean(x, na.rm = TRUE))
plot.with.model(bw.decomp$u[,1], ordered.bw[bw.decomp$rows.used,"weight_final"],
  xlab = "PC1 of weight matrix", ylab = "Final Weight")

#plot.with.model(bw.decomp$u[,1], avg.weight[bw.decomp$rows.used],
#  xlab = "PC1 of weight matrix", ylab = "Average Weight")
```

```{r final_trait_mat}
#initialize a trait matrix that contains all the traits we want to examine.
final.trait.mat <- num.pheno[,"weight_final",drop=FALSE]

male.wt <- num.pheno[]
```

## Food consumption

We also looked at the range of food consumption.
The following boxplot shows that there is a clear
error in the food consumption measurements. We
removed the measurement that was greater than 40.

```{r food}
food.idx <- grep("food", colnames(num.pheno))
food.mat <- num.pheno[,food.idx]
boxplot(food.mat, las = 2)
```

The following matrix shows food consumption after
removing the error.

Unlike weight, food consumption remained fairly 
steady over the course of the experiment. 

```{r remove_food_error}
outlier1 <- which(food.mat > 40)
food.mat[outlier1] <- NA
boxplot(food.mat, las = 2)
```

The food consumption matrix is also predominantly
in one dimention.

```{r food_decomp, warning = FALSE}
food.decomp <- plot.decomp(food.mat, plot.results = FALSE)
barplot_with_num(round(food.decomp$var.exp, 2), text.srt = 45)
```
This dimension is even more highly correlated with 
the average food intake, so we can safely reduce
food intake to its averge.

```{r food_pc}
plot.with.model(food.decomp$u[,1], food.mat[food.decomp$rows.used,"food_ave"],
  xlab = "PC1 of food intake", ylab = "Food Intake Average")
```

There is a weak relationship between food consumption and 
final weight.

```{r weight_v_food}
food.weight.stats <- plot.with.model(food.mat[,"food_ave"], ordered.bw[,"weight_final"],
  xlab = "Avg. Food Consumption", ylab = "Weight (g)")
```

Some of the animals are crumblers, which means they store
food in their bedding. This will falsely increase the amount
of food they are consuming. However, I can't find any data 
to indicate which mice are crumblers and which are not.

The phenotypes fall into multiple categories, and some 
are normalized in different ways; i.e. adjusted for baseline
measurements or not, rank Z normalized or not. We don't want
to use all traits indiscriminately. Here we select traits 
for merging into a combined matrix that will capture multiple
dimensions of the metabolic state of the animals.

```{r add_food_consumption}
final.trait.mat <- cbind(final.trait.mat, food.mat[,"food_ave", drop=FALSE])
```

## Glucose

For glucose measurements we will look at glu_final, the 
final glucose measurement for each animal.

This measurement of glucose has the most variation.
It also captures the difference between animals whose glucose measurements
went up over the course of the experiment and those whose glucose
measurements went down over the course of the experiment. There is a 
slight negative correlation between initial glucose measurement and 
final glucose measurement. That is, animals that started with higher
glucose measurements tended to end with lower glucose measurements.

```{r glucose, fig.width = 8, fig.height = 8}

glu.mat <- num.pheno[,c("glu_6", "glu_10", "glu_14", "glu_final")]
glu.mat[352,] <- NA
glu.diff <- glu.mat[,"glu_final"] - glu.mat[,"glu_6"] #did glucose go up or down over the course of the experiment?
glu.dir <- rep(NA, nrow(glu.mat))
glu.up <- which(glu.diff > 0) 
glu.down <- which(glu.diff < 0)
glu.dir[glu.up] <- "Up"
glu.dir[glu.down] <- "Down"

par(mfrow = c(2,2))
boxplot(glu.mat[,"glu_6"]~as.factor(glu.dir), xlab = "Glucose Change", 
  ylab = "Initial Glucose")
plot.with.model(glu.mat[,"glu_6"], glu.diff, report = "cor.test",
  xlab = "Initial Glucose", ylab = "Glucose Change")
plot.with.model(glu.mat[,"glu_final"], glu.diff, report = "cor.test",
  xlab = "Final Glucose", ylab = "Glucose Change")

```

```{r ins_hist}
glu <- num.pheno[, "glu_final"]
weight <- num.pheno[, "weight_final"]
sex <- as.numeric(as.factor(covar[,1]))
not.outlier <- which(glu < 800)

fig1abcde.data <- data.frame("ID" = rownames(num.pheno)[not.outlier], 
  "Sex" = covar[not.outlier,1], 
  "Food_Consumption" = num.pheno[not.outlier,"food_ave"], 
  "Glucose" = glu[not.outlier], "Body_Weight" = weight[not.outlier])

write_table_with_header(fig1abcde.data, file.path(figure.data.dir, "Fig1A-E.txt"),
  header = "Data for Figure 1 panels A-E")

pdf(here("Results", "Paper", "Fig1A_B.pdf"), height = 3, width = 4)

#fasting glucose as densities
f.locale <- which(sex == 1)
m.locale <- which(sex == 2)
f.dens <- density(glu[intersect(f.locale, not.outlier)])
m.dens <- density(glu[intersect(m.locale, not.outlier)])
x.max <- max(c(f.dens$x, m.dens$x))
y.max <- max(c(f.dens$y, m.dens$y))
fcol <- rgb(126/256, 205/256, 97/256, alpha = 0.5)
mcol <- rgb(74/256, 149/256, 224/256, alpha = 0.5)

par(mar = c(4,4,2,2))
plot.new()
plot.window(xlim = c(0, x.max), ylim = c(0, y.max))
plot.poly.xy(poly.top.x = f.dens$x, poly.top.y = f.dens$y, poly.bottom.x = f.dens$x,
  poly.bottom.y = rep(0, length(f.dens$y)), col = fcol)
plot.poly.xy(poly.top.x = m.dens$x, poly.top.y = m.dens$y, poly.bottom.x = m.dens$x,
  poly.bottom.y = rep(0, length(m.dens$y)), col = mcol)
axis(1)
axis(2)
mtext("Fasting Glucose (mg/dL)", side = 1, line = 2.5)
mtext("Density", side = 2, line = 2.5)

#diabetic range from PMID
#will need to find real values for this. They vary an unbelievable amount.
#glucose.ranges <- c(250, 300) 

#abline(v = glucose.ranges)

normal.col <- rgb(195/256, 235/256, 173/256)
pre.col <- rgb(247/256, 220/256, 155/256)
diab.col <- rgb(239/256, 171/256, 162/256)
plot.dim = par("usr")
plot.height <- plot.dim[4] - plot.dim[3]
draw.rectangle(min(f.dens$x), glucose.ranges[1], 0, 0-(plot.height*0.035), fill = normal.col)
draw.rectangle(glucose.ranges[1], glucose.ranges[2], 0, 0-(plot.height*0.035), fill = pre.col)
draw.rectangle(glucose.ranges[2], max(m.dens$x), 0, 0-(plot.height*0.035), fill = diab.col)

legend(225, 0.012, lwd = 10, col = c(fcol, mcol), legend = c("female", "male"), cex = 0.8)
legend(225, 0.008, fill = c(normal.col, pre.col, diab.col), 
  legend = c("normal", "pre-diabetes", "diabetes"), cex = 0.8)

#body weight as densities
f.locale <- which(sex == 1)
m.locale <- which(sex == 2)
f.bw <- num.pheno[f.locale,"weight_final"]
f.bw <- f.bw[which(!is.na(f.bw))]
f.dens <- density(f.bw)
m.bw <- num.pheno[m.locale,"weight_final"]
m.bw <- m.bw[which(!is.na(m.bw))]
m.dens <- density(m.bw)
x.max <- max(c(f.dens$x, m.dens$x))
y.max <- max(c(f.dens$y, m.dens$y))
fcol <- rgb(126/256, 205/256, 97/256, alpha = 0.5)
mcol <- rgb(74/256, 149/256, 224/256, alpha = 0.5)

par(mar = c(4,4,2,2))
plot.new()
plot.window(xlim = c(0, x.max), ylim = c(0, y.max))
plot.poly.xy(poly.top.x = f.dens$x, poly.top.y = f.dens$y, poly.bottom.x = f.dens$x,
  poly.bottom.y = rep(0, length(f.dens$y)), col = fcol)
plot.poly.xy(poly.top.x = m.dens$x, poly.top.y = m.dens$y, poly.bottom.x = m.dens$x,
  poly.bottom.y = rep(0, length(m.dens$y)), col = mcol)
axis(1)
axis(2)
mtext("Body Weight (g)", side = 1, line = 2.5)
mtext("Density", side = 2, line = 2.5)

#avg weight at 20 wks from https://www.jax.org/jax-mice-and-services/strain-data-sheet-pages/body-weight-chart-000664
f.avg = 25.3; f.dev = 2.8
m.avg = 34.2; m.dev = 2.9
plot.dim <- par("usr")
plot.height <- plot.dim[4] - plot.dim[3]
draw.rectangle(f.avg - f.dev, f.avg + f.dev, 0, 0-(plot.height*0.035), fill = fcol)
draw.rectangle(m.avg - m.dev, m.avg + m.dev, 0, 0-(plot.height*0.035), fill = mcol)

legend(45, 0.08, lwd = 10, col = c(fcol, mcol), legend = c("female", "male"), cex = 0.8)
legend(45, 0.05, fill = c(fcol, mcol), cex = 0.8,
  legend = c("B6 wt. (F)", "B6 wt. (M)"))

dev.off()

sex.label = c("Female", "Male")
pdf(here("Results", "Paper", "Fig1C.pdf"), height = 4, width = 4)
par(mar = c(4,8,4,4))
model <- lm(glu[not.outlier]~sex[not.outlier]) 
f <- summary(model)$fstatistic
p.text <- threshold_p(pf(f[1],f[2],f[3],lower.tail=F), return.text = TRUE)
n.fm <- sapply(1:2, function(x) length(which(sex[not.outlier] == x)))
boxplot(glu[not.outlier]~sex[not.outlier], names = NA, , xlab = "",
  ylab = "Fasting Glucose (mg/dL)", col = c(fcol, mcol))
plot.text(p.text, rel.x = 0.02, rel.y = 0.95, add = TRUE, adj = 0)
par(xpd = NA)
for(i in 1:2){
  text(i, y = 10, labels = sex.label[i])
  text(i, y = -15, labels = bquote(italic(n) == .(n.fm[i])))
}
par(xpd = TRUE)
dev.off()


pdf(here("Results", "Paper", "Fig1D_E.pdf"), height = 3, width = 4)
par(mar = c(4,4,1,2))
weight.glu.stats <- plot.with.model(weight[not.outlier], glu[not.outlier], xlab = "",
  ylab = "", col = sex+2, write.results = FALSE)
mtext("Weight (g)", side = 1, line = 2.5, cex = 1)
mtext("Fasting Glucose (mg/dL)", side = 2, line = 2.5, cex = 1)
text(x = 15, y = 365, labels = bquote(italic(R)^2 == .(weight.glu.stats[1])), adj = 0)
text(x = 15, y = 325, labels = bquote(italic(p) < .(signif(weight.glu.stats[2], 2))), adj = 0)
paper.data <- record_result(weight.glu.stats, paper.data$paper.data, "weight_glu", paper.data$data.idx)

food.weight.stats <- plot.with.model(num.pheno[,"food_ave"], num.pheno[,"weight_final"],
  ylab = "", xlab = "", col = sex+2,
  write.results = FALSE)
mtext("Avg Food Consumption (AU)", side = 1, line = 2.5, cex = 1)
mtext("Weight (g)", side = 2, line = 2.5, cex = 1)
text(x = 1.8, y = 68, labels = bquote(italic(R)^2 == .(food.weight.stats[1])), adj = 0)
text(x = 1.8, y = 61, labels = bquote(italic(p) < .(signif(food.weight.stats[2], 2))), adj = 0)
paper.data <- record_result(food.weight.stats, paper.data$paper.data, "food_weight", paper.data$data.idx)
dev.off()

paper.data <- record_result(list("Male" = m.bw, "Female" = f.bw), paper.data$paper.data, 
  "Body_Weight", paper.data$data.idx)
```


```{r add_final_glucose}
final.trait.mat <- cbind(final.trait.mat, num.pheno[,"glu_final",drop=FALSE])
```

We also use the glucose total area under the curve. 
It is more highly correlated with final body weight
than is glu_iAUC.

```{r glucose_curves, fig.width = 8, fig.height = 8}
par(mfrow = c(2,2))
plot.with.model(num.pheno[,"Glu_tAUC"], num.pheno[,"Glu_iAUC"],
  xlab = "Glu_tAUC", ylab = "Glu_iAUC")
plot.with.model(num.pheno[,"Glu_iAUC"], num.pheno[,"weight_final"],
  xlab = "Glu_iAUC", ylab = "final weight")

plot.with.model(num.pheno[,"Glu_tAUC"], 
  num.pheno[,"weight_final"], xlab = "Glu_tAUC", ylab = "final weight")
```

```{r perc_diabetic}
num.prediab <- length(intersect(which(num.pheno[,"glu_final"] >= glucose.ranges[1]), which(num.pheno[,"glu_final"] < glucose.ranges[2])))
perc.prediab <- (num.prediab/nrow(num.pheno))*100
prediab <- c("Num_pre-diabetic" = num.prediab, "Perc_pre-diabetic" = perc.prediab)
paper.data <- record_result(prediab, paper.data$paper.data, "Prediabetic", paper.data$data.idx)

num.diabetic <- length(which(num.pheno[,"glu_final"] >= glucose.ranges[2]))
perc.diabetic <- (num.diabetic/nrow(num.pheno))*100
diabetic <- c("Num_diabetic" = num.diabetic, "Perc_diabetic" = perc.diabetic)
paper.data <- record_result(diabetic, paper.data$paper.data, "Diabetic", paper.data$data.idx)
```

```{r add_glu_tAUC}
final.trait.mat <- cbind(final.trait.mat, num.pheno[,"Glu_tAUC",drop=FALSE])
```

## Insulin 

Final insulin levels are also a good single measurement. 
This measurement captures the most variance, and is highly
correlated with the change in insulin over the course of the
experiment.

There is no correlation between initial insulin measurements
and the change in insulin over the course of the experiment.

```{r ins_levels, fig.width = 8, fig.height = 4}

ins.mat <- num.pheno[,c("ins_6", "ins_10", "ins_14", "ins_final")]
ins.diff <- num.pheno[,"ins_final"] - num.pheno[,"ins_6"]

par(mfrow = c(1,2))
plot.with.model(ins.mat[,"ins_6"], ins.diff, xlab = "Initial Insulin", 
  ylab = "Insulin Change", report = "cor.test")
plot.with.model(ins.mat[,"ins_final"], ins.diff, xlab = "Final Insulin",
  ylab = "Insulin Change", report = "cor.test")
```


```{r add_ins_final}
final.trait.mat <- cbind(final.trait.mat, num.pheno[,"ins_final",drop=FALSE])
```

For the insulin curves, we will select Ins_tAUC. 
This measurement is positively correlated with 
final body weight. The adjusted insulin AUC,
however, has a strange relationship with other traits
like final weight.

```{r ins_curves, fig.height = 4, fig.width = 8}

par(mfrow = c(1,2))
plot.with.model(num.pheno[,"Ins_tAUC"], num.pheno[,"weight_final"],
  xlab = "total insulin AUC", ylab = "final body weight", report = "cor.test")
plot.with.model(num.pheno[,"Ins_iAUC"], num.pheno[,"weight_final"],
  xlab = "adjusted insulin AUC", ylab = "final body weight", report = "cor.test")
```

```{r add_ins_tAUC}
final.trait.mat <- cbind(final.trait.mat, num.pheno[,"Ins_tAUC", drop=FALSE])
```

## Triglycerides

There is an outlier in the first TG measurement at 6 weeks.
I'm going to remove it on suspicion that it is an error.

```{r tg}
tg.mat <- num.pheno[,c("TG_6", "TG_10", "TG_14", "TG_final")]
boxplot(tg.mat)
outliers <- which(tg.mat > 600)
tg.mat[outliers] <- NA
```

The TG measurements have an interesting pattern: 
increasing early on from baseline, and then 
decreasing again.

```{r tg_final}
boxplot(tg.mat)
```

I think it probably makes sense to use only the final TG 
measurement. This will be the most advanced in terms of 
metabolic disease, and will avoid complicated interpretation 
of earlier timepoints or principal components.


```{r add_tg}
final.trait.mat <- cbind(final.trait.mat, tg.mat[,"TG_final",drop=FALSE])
```


## Pancreas traits and HOMA

We selected all three pancreas traits: WPIC, 
Ins_per_islet, and num_islets. And both HOMA
traits

```{r add_panc_traits}
final.trait.mat <- cbind(final.trait.mat, 
  num.pheno[,c("WPIC", "Ins_per_islet", "num_islets", "HOMA_B", "HOMA_IR")])
```

## Cholesterol

The cholesterol measurements are positively correlated.


```{r chol}
chol.traits <- c("HDL_3_2a", "HDL_2b", "Mid_Zone", "LDL_IVc", 
  "LDL_IVb", "LDL_IVa", "LDL_IIIb", "LDL_IIIa", "LDL_IIb", 
  "LDL_IIa", "LDL_I", "IDL_2", "IDL_1", "VLDL_sm", "VLDL_int", 
  "VLDL_lg")

chol.mat <- num.pheno[,chol.traits]
keep.rows <- which(apply(chol.mat, 1, function(x) !all(is.na(x))))
chol.mat <- chol.mat[keep.rows,]
pheatmap(cor(chol.mat))
```

It probably makes sense to divide up the cholesterol 
measurements by LDL, HDL, etc. For each set of 
measurements, we will use the first PC to summarize
the class as a whole. The variance explained by 
each of these PC1s is shown below. For each class,
we capture the vast majority of the variation.

We test whether each PC is correlated or anticorrelated
with the average of the values. If it is anticorrelated
we multipley the PC by -1 to make sure all PCs are 
covarying as the measurements do.

```{r chol_class}
chol.class <- c("HDL", "LDL", "IDL", "VLDL")
class.sep <- sapply(strsplit(chol.traits, "_"), function(x) x[1])
class.idx <- lapply(chol.class, function(x) which(class.sep == x))
names(class.idx) <- chol.class

chol.pc.mat <- matrix(NA, nrow = nrow(chol.mat), ncol = length(chol.class))
rownames(chol.pc.mat) <- rownames(chol.mat)
colnames(chol.pc.mat) <- chol.class

par(mfrow = c(2,2))
for(i in 1:length(class.idx)){
  class.vals <- chol.mat[,class.idx[[i]]]
  class.decomp <- plot.decomp(class.vals, main = class.sep[i])
  chol.pc <- class.decomp$u[,1]
  class.avg <- rowMeans(class.vals)
  #plot(chol.pc, class.avg)
  avg.cor <- cor(chol.pc, class.avg)
  if(avg.cor < 0){
    chol.pc.mat[,i] <- chol.pc*-1
  }else{
    chol.pc.mat[,i] <- chol.pc
  }
}
```

All classes were positively correlated with each other
as seen in the raw measurements. LDLs and IDLs were most
positively correlated. 

```{r class_cor}
pheatmap(cor(chol.pc.mat), display_numbers = TRUE)
```


```{r full_chol_pc_mat}
#add NAs for individuals without cholesterol measurements
excluded.names <- setdiff(rownames(final.trait.mat), rownames(chol.pc.mat))
chol.pc.padding <- matrix(NA, nrow = length(excluded.names), ncol = ncol(chol.pc.mat))
rownames(chol.pc.padding) <- excluded.names
colnames(chol.pc.padding) <- colnames(chol.pc.mat)
full.pc.mat <- rbind(chol.pc.padding, chol.pc.mat)
row.order <- match(rownames(final.trait.mat), rownames(full.pc.mat))
final.pc.mat <- full.pc.mat[row.order,]
#identical(rownames(final.pc.mat), rownames(final.trait.mat))
```

```{r add_chol_pc}
final.trait.mat <- cbind(final.trait.mat, final.pc.mat)
```

## The rest

We added:

* the rank Z normalized glycogen measurement.

* the rank Z normalized proinsulin measurement.

* Gcg content

* Gcg secreted

* tibia bone mineral density (BMD)

* leptin and adiponectin levels

* organ weights (heart, liver, fat pad)

* adiposity

```{r add_the_rest}
final.trait.mat <- cbind(final.trait.mat, 
  num.pheno[,c("glycogen_rz", "proinsulin_rz", "Gcg_content", "Gcg_secreted",
  "BMD", "leptin", "adiponectin", "heart_weight", "liver_weight",
  "fat_pad_weight", "adiposity")])
```

The following barplot shows the number of individuals
with measurements for each trait. Some of them don't have
many individuals.

```{r ind_count, fig.width = 8, fig.height = 5}
ind.count <- apply(final.trait.mat, 2, function(x) length(which(!is.na(x))))
par(mar = c(8, 4, 4, 4))
barplot_with_num(ind.count, las = 2, text.srt = 45, text.gap = 0.2, 
  text.shift = 0.1)

total.ind <- length(which(!is.na(rowSums(final.trait.mat))))
```

If we use the full matrix, there are only `r total.ind` individuals
with all traits measured. Unfortunately we'll have to 
pare down even from here which traits to use. 

The following heatmap shows where blocks of missing 
individuals are. We will remove the organ weights, 
leptin, adiponectin, and glucagon, and adiposity. 

```{r remove_which}
remove.traits <- c("Gcg_content", "Gcg_secreted", "adiponectin",
  "leptin", "heart_weight", "liver_weight", "fat_pad_weight", "adiposity")

is.included <- rep("yes", ncol(final.trait.mat))
not.included <- which(colnames(final.trait.mat) %in% remove.traits)
is.included[not.included] <- "no"
included <- data.frame("included" = is.included)
rownames(included) <- colnames(final.trait.mat)
```

```{r missing_ind, fig.width = 8, fig.height = 6}
pheatmap(final.trait.mat, cluster_rows = FALSE, cluster_cols = FALSE,
  show_rownames = FALSE, annotation_col = included)
```

Before we remove the traits with lots of missing values, we
looked at the correlation matrix for these traits to compare
with the PC matrix below. I used Spearman rank correlation
because some of these traits have really weird distributions.

```{r trait_cor, fig.width = 9, fig.height = 7}
full.cor <- cor(final.trait.mat, use = "pairwise.complete.obs", method = "spearman")
pheatmap(full.cor, annotation_row = included)
```

The following heatmap shows the correlation matrix
only for the traits that are included in the final 
trait set.

```{r remove_missing, warning = FALSE, fig.width = 7, fig.height = 7}
keep.traits <- setdiff(colnames(final.trait.mat), remove.traits)
pared.traits <- final.trait.mat[,keep.traits]

norm.traits <- apply(pared.traits, 2, rankZ)
norm.cor <- cor(norm.traits, use = "pairwise.complete.obs")


pheatmap(norm.cor, cellwidth = 12, cellheight = 12)


norm.decomp <- plot.decomp(norm.traits, pc = ncol(norm.traits), plot.results = FALSE)
#barplot_with_num(round(norm.decomp$var.exp, 2))

```

This trait set includes `r nrow(norm.decomp$u)` animals.
Some of the excluded traits are correlated with the first PC of this
matrix. The organ weights and leptin levels are correlated with 
insulin_tAUC and HOMA_IR. However, adiposity, adiponectin, and 
glucagon are not correlated with anything else in this matrix.

I'm not sure how adiposity was measured. It doesn't have an 
explanation in the phenotype annotation matrix. Although fat
pad weight and body weight are highly correlated, neither
is correlated with adiposity, which makes me suspicious of that
measurement.

Why are those cholesterol PCs dominating some of the PCs?
Is that a problem? Is it interesting?


```{r pc_v_traits, fig.width = 7, fig.height = 7}
trait.cor.mat <- matrix(NA, nrow = ncol(norm.decomp$u), 
  ncol = ncol(final.trait.mat))
colnames(trait.cor.mat) <- colnames(final.trait.mat)
rownames(trait.cor.mat) <- paste0("PC", 1:nrow(trait.cor.mat))

for(i in 1:ncol(norm.decomp$u)){ #for each PC
  trait.cor <- apply(final.trait.mat[norm.decomp$rows.used,], 2,
    function(x) cor(x, norm.decomp$u[,i], use = "pairwise.complete.obs", method = "spearman"))
  trait.cor.mat[i,] <- trait.cor
}

pheatmap(t(trait.cor.mat), cluster_cols = FALSE, annotation_row = included)
```

The variance explained by each of these PCs is the following.

```{r var_exp, fig.width = 7, fig.height = 5}
var.exp <- round(norm.decomp$var.exp, 2)
names(var.exp) <- paste("PC", 1:length(var.exp))
barplot_with_num(var.exp, las = 2, text.srt = 45)
```

```{r test, eval = FALSE}
pc.num = 1
trait.name = "leptin"
plot.with.model(rankZ(norm.decomp$u[,pc.num]), 
  rankZ(final.trait.mat[norm.decomp$rows.used,trait.name]), report = "cor.test",
  xlab = paste("PC", pc.num), ylab = trait.name)

plot.with.model(rankZ(final.trait.mat[,"fat_pad_weight"]), 
  rankZ(final.trait.mat[,"weight_final"]), report = "cor.test")

```

## Heritability

The following plot shows the estimated heritablity of each 
trait. Some traits have very low heritability, but we will 
not remove them. Heritability estimates have very wide error
bars, and we don't want to exclude potentially informative 
traits a priori. 

```{r herit, fig.width = 5, fig.height = 5}
library(qtl2)

kin.file <- file.path(parsed.data.dir, "overall.kinship.RDS")
if(!file.exists(kin.file)){
  load(here("Data", "DO", "QTLViewer_Geno_V10.Rdata")) #ensembl.version, genoprobs, K, map, markers
  Kg = calc_kinship(genoprobs, "overall")
  saveRDS(Kg, kin.file)
}else{
  Kg <- readRDS(kin.file)
}


herit  <- est_herit(norm.traits, Kg, addcovar = num.covar)
herit_error <- est_herit_error(norm.traits, Kg)
herit.min <- as.numeric(herit) - herit_error
herit.max <- as.numeric(herit) + herit_error
ylim <- get_plot_bounds(min.val = min(herit.min), max.val = max(herit.max), 
  scale.factor = 10, return.even = TRUE)
herit.order <- order(as.numeric(herit))

plot.new()
plot.window(xlim = c(min(herit.min), max(herit.max)), ylim = c(1, length(herit)))
segments(y0 = 1:length(herit), x0 = herit.min[herit.order], x1 = herit.max[herit.order])
segments(y0 = 1:length(herit)-0.2, y1 = 1:length(herit)+0.2, x0 = herit.min[herit.order])
segments(y0 = 1:length(herit)-0.2, y1 = 1:length(herit)+0.2, x0 = herit.max[herit.order])
points(y = 1:length(herit), x = herit[herit.order], pch = 16, cex = 1.5, col = "darkgray")
axis(1)
abline(v = 0)
abline(v = seq(0.1, 0.6, 0.1), lty = 2, col = "gray")
mtext("Heritability", side = 1, line = 2)

par(xpd = NA)
text(y = 1:length(herit), x = min(herit.min)-0.01, labels = names(herit)[herit.order], 
  adj = 1)
par(xpd = TRUE)
#barplot(as.numeric(herit)[herit.order], names = colnames(norm.traits)[herit.order], las = 2,
#  ylab = "Heritability", ylim = ylim)
#abline(h = seq(0, ylim[2], 0.1), lty = 2, col = "darkgray")
```


## Adjusting

The phenotypes need to be all on the same scale for
later analyses. Here we first rank Z normalize to 
minimize the effects of outliers, then we regress 
out the covariates, and finally we mean center and 
standardize so that all traits have a variance of 1.

```{r adjust}

#adjust out covariates
#remove sex, wave, and generation from the phenotypes
adj.pheno <- adjust(norm.traits, num.covar) 

#mean center and standardize
scaled.pheno <- apply(adj.pheno, 2, function(x) scale(x, center = TRUE, scale = TRUE))
rownames(scaled.pheno) <- rownames(adj.pheno)
```

The following plot shows the contributions of each trait to 
the principal components of the trait matrix. The bars
along the top show the variance explained by each PC.

The traits are renamed to be more descriptive. These names are
stored in Data/DO/trait_names.csv


```{r trait_pc, fig.height = 6, fig.width = 5}
descriptive_names <- read.csv(here("Data", "DO", "trait_names.csv"), header = FALSE)
matched_names <- descriptive_names[sapply(colnames(scaled.pheno), function(x) which(descriptive_names[,1] == x)),2]

trait.decomp <- plot.decomp(scaled.pheno, pc = ncol(scaled.pheno), plot.results = FALSE)
pc.mat <- trait.decomp$v
colnames(pc.mat) <- paste0("PC", 1:ncol(pc.mat))
rownames(pc.mat) <- matched_names

write_table_with_header(pc.mat, file.path(figure.data.dir, "Supp_Fig1A-B.txt"),
  header = "Data for Supplemental Figures 1B. Contributions 
  of each trait to each eigenvector derived from the singular
  value decomposition of the trait matrix. PC1 and PC2 were 
  used to generate Supp. Fig. 1B.")

pc.var = data.frame("PC" = colnames(pc.mat), 
  "Var_Exp" = round(trait.decomp$var.exp*100))
write_table_with_header(pc.var, file.path(figure.data.dir, "Supp_Fig1A.txt"),
  header = "Data for Supplemental Figure 1A. Percent trait 
  variance explained for each principal component
  rounded to the nearest whole number.")


#png("~/Desktop/trait_pc.png", width = 6, height = 7, units = "in", res = 100)
layout(matrix(c(1,2,3), ncol = 1), heights = c(0.5, 1, 0.2))
par(mar = c(0, 7.7, 4, 3.7))
barplot_with_num(round(trait.decomp$var.exp*100), ylab = "% Variance Explained")
par(mar = c(4,8,0,4))
imageWithText(pc.mat*-1, use.pheatmap.colors = TRUE, show.text = FALSE, row.text.shift = 0.04,
  col.text.shift = 0.04)
par(mar = c(4,14,0,14))
imageWithTextColorbar(pc.mat, use.pheatmap.colors = TRUE, bar.lwd = 3, cex = 1.5,
  orientation = "h", axis.line = 1.5)
#dev.off()


```

The final phenotype matrix is stored in the Data folder in the file
Clinical_Phenotypes_Adjusted.RDS

The names in this final matrix are the same as in the above plot.

```{r write_data}
colnames(scaled.pheno) <- matched_names
saveRDS(scaled.pheno, file.path(parsed.data.dir, "Clinical_Phenotypes_Adjusted.RDS"))
```

The following heatmap shows the trait correlations with their final names.

```{r final_cor, fig.height = 7, fig.width = 7}
pheno.cor <- cor(scaled.pheno, use = "pairwise.complete.obs")
pheatmap(pheno.cor, cellwidth = 12, cellheight = 12)
```

The following plot shows the heritabilities of the final traits with their 
final names.

```{r final_herit, fig.width = 5, fig.height = 5}

herit  <- est_herit(scaled.pheno, Kg, addcovar = num.covar)
herit_error <- est_herit_error(scaled.pheno, Kg)
max.herit <- as.numeric(herit) + herit_error
min.herit <- as.numeric(herit) - herit_error
xlim <- get_plot_bounds(min.val = 0, max.val = (max(max.herit)), 
  scale.factor = 20, return.even = TRUE)
herit.order <- order(as.numeric(herit))


fig1F_data <- data.frame("Trait" = names(herit_error), 
  "Heritability_Estimate" = as.numeric(herit),
  "Estimate_Error" = herit_error)

write_table_with_header(fig1F_data, file.path(figure.data.dir, "Fig1F.txt"), 
  header = "Data for Figure 1F.")

#vertical
par(mar = c(4, 8, 4, 2))
plot.new()
plot.window(xlim = xlim, ylim = c(0, length(herit)))
segments(x0 = min.herit[herit.order], x1 = max.herit[herit.order], y0 = 1:length(herit))
segments(x0 = min.herit[herit.order], y0 = 1:length(herit)-0.2, y1 = 1:length(herit)+0.2)
segments(x0 = max.herit[herit.order], y0 = 1:length(herit)-0.2, y1 = 1:length(herit)+0.2)
points(y = 1:length(herit), x = as.numeric(herit)[herit.order])
abline(v = seq(0, xlim[2], 0.1), lty = 2, col = "gray")
axis(1)
mtext("Heritability", side = 1, line = 2.5)
par(xpd = NA)
text(x = min(min.herit)-0.02, y = 1:length(herit), gsub("_", " ", names(max.herit)[herit.order]), adj = 1)
par(xpd = TRUE)


#horizontal
n.ind <- apply(scaled.pheno, 2, function(x) length(which(!is.na(x))))

pdf(here("Results", "Paper", "Fig1F.pdf"), width = 8, height = 4.5)
herit.order <- order(as.numeric(herit), decreasing = TRUE)
par(mar = c(9, 4, 2, 2))
plot.new()
plot.window(ylim = xlim, xlim = c(0, length(herit)))
segments(y0 = min.herit[herit.order], y1 = max.herit[herit.order], x0 = 1:length(herit))
segments(y0 = min.herit[herit.order], x0 = 1:length(herit)-0.2, x1 = 1:length(herit)+0.2)
segments(y0 = max.herit[herit.order], x0 = 1:length(herit)-0.2, x1 = 1:length(herit)+0.2)
points(x = 1:length(herit), y = as.numeric(herit)[herit.order])
abline(h = seq(0, xlim[2], 0.1), lty = 2, col = "gray")
axis(2)
mtext("Heritability", side = 2, line = 2.5)
par(xpd = NA)
text(y = min(min.herit)-0.02, x = 1:length(herit), 
  paste0(gsub("_", " ", names(max.herit)[herit.order]), " (", n.ind[herit.order], ")"), 
  adj = 1, srt = 90)
par(xpd = TRUE)
dev.off()

```

```{r save_paper_data}
saveRDS(paper.data$paper.data, file.path(paper.data.dir, "pheno_stats.RDS"))
```


The following heat map shows the trait correlations
in the upper triangle, genetic correlations in the 
lower triangle, and trait heritabilities on the diagonal
at the request of reviewer 3.

```{r cor_herit}
#keep the phenotype clustering order
#trait.order <- hclust(dist(pheno.cor))$order
#herit.cor <- pheno.cor
#diag(herit.cor) <- herit
genetic.cor.file <- file.path(parsed.data.dir, "Genetic_Correlations.RDS")

if(!file.exists(genetic.cor.file)){
  load(here("Data", "DO", "QTLViewer_Geno_V10.Rdata")) #ensembl.version, genoprobs, K, map, markers
  trait.scan <- scan1(genoprobs, scaled.pheno, addcovar = num.covar, kinship = Kg)
  trait.lod <- as.matrix(trait.scan)
  #hist(rowSums(trait.lod))
  keep.rows <- which(rowSums(trait.lod) > 8) #filter to QTL
  #keep.rows <- 1:nrow(trait.lod) #no filter
  #the filter doesn't make a difference
  genetic.cor <- cor(trait.lod[keep.rows,])
  saveRDS(genetic.cor, genetic.cor.file)
}else{
  genetic.cor <- readRDS(genetic.cor.file)
}

#=======================================
## playing around with trait clustering
#=======================================
cor.decomp <- plot.decomp(pheno.cor, label.points = TRUE)
pam.cl <- pam(cor.decomp$u, k = 4)
plot(cor.decomp$u, col = pam.cl$clustering, pch = 16)
text(cor.decomp$u[,1], cor.decomp$u[,2], labels = colnames(pheno.cor), pos = 4)

net <- graph_from_adjacency_matrix(abs(pheno.cor), weighted = TRUE, mode = "undirected")
net.cl <- cluster_fast_greedy(net)
net.cl$membership
plot(cor.decomp$u, col = net.cl$membership, pch = 16)
text(cor.decomp$u[,1], cor.decomp$u[,2], labels = colnames(pheno.cor), pos = 4)


trait.clust <- hclust(dist(pheno.cor)) #ignore heritability on the diagonal
#trait.clust <- hclust(dist(herit.cor)) #clustering with heritability on diagonal
pheno.cor.order <- trait.clust$order

geno.clust <- hclust(dist(genetic.cor))
geno.cor.order <- geno.clust$order
#=======================================


#=======================================
#set trait order and clustering method
#trait.order <- geno.cor.order #order by hierarchical clustering of genetic correlations
trait.order <- pheno.cor.order #order by hierarchical clustering of phenotype correlations
#trait.order <- order(pam.cl$clustering) #order by pam clustering of phenotype correlation decomposition
#trait.order <- order(net.cl$membership) #order by fast-greedy clustering of adjacency matrix

#make sure clustering is compatible with the row order
trait.cl <- pam.cl$clustering #clusters set by pam 
#trait.cl <- net.cl$membership #clusters set by fast-greedy

trait.order <- order(trait.cl)
#=======================================


#because these are laboratory animals, the phenotype 
#and genetic correlations are highly correlated
#plot(pheno.cor, genetic.cor)

#If we order the rows and columns after putting in the values
#the triangles get mixed up. Here we put the values in alread
#clustered by phenotype correlation
get_tri_idx <- function(mat, label1, label2, tri.which = c("upper", "lower")){

  tri.which <- tri.which[1] #default to upper tri

  idx1 <- which(rownames(mat) == label1)
  idx2 <- which(colnames(mat) == label2)
  
  #find the indices for each index in either row or column position
  test.idx1 <- row_col_to_idx(idx1, idx2, n.row = nrow(mat))
  test.idx2 <- row_col_to_idx(idx2, idx1, n.row = nrow(mat))

  upper.tri.idx <- which(upper.tri(mat))
  lower.tri.idx <- which(lower.tri(mat))

  #if we have asked for the index in the upper tri
  if(tri.which == "upper"){
    test.upper1 <- intersect(test.idx1, upper.tri.idx)
    test.upper2 <- intersect(test.idx2, upper.tri.idx)
    final.idx <- union(test.upper1, test.upper2)
  }
  if(tri.which == "lower"){
    test.lower1 <- intersect(test.idx1, lower.tri.idx)
    test.lower2 <- intersect(test.idx2, lower.tri.idx)
    final.idx <- union(test.lower1, test.lower2)
  }
  return(final.idx)
}


combo.mat <- cor.class <- matrix(NA, nrow = ncol(genetic.cor), ncol = ncol(genetic.cor))
colnames(combo.mat) <- colnames(cor.class) <- colnames(genetic.cor)[trait.order]
rownames(combo.mat) <- rownames(cor.class) <- rownames(genetic.cor)[trait.order]

trait.pairs <- pair.matrix(colnames(genetic.cor))
for(i in 1:nrow(trait.pairs)){
  trait1 <- trait.pairs[i,1]
  trait2 <- trait.pairs[i,2]

  upper.tri.idx <- get_tri_idx(genetic.cor[trait.order, trait.order], trait1, trait2, "upper")
  lower.tri.idx <- get_tri_idx(genetic.cor[trait.order, trait.order], trait1, trait2, "lower")

  combo.mat[upper.tri.idx] <- genetic.cor[trait1, trait2] #put the genetic cor in the upper triangle, use names to index
  combo.mat[lower.tri.idx] <- pheno.cor[trait1, trait2] #put the phenotype cor in the lower triangle, use names to index

  #make the class matrix at the same time to check that 
  #we are putting things in the right places
  cor.class[upper.tri.idx] <- 1
  cor.class[lower.tri.idx] <- 2
}

diag(combo.mat) <- as.numeric(herit)[trait.order]
diag(cor.class) <- 3
#image(class.mat)

cor.class.cols <- c("blue", "purple", "yellow")

highlight.clusters = FALSE

write_table_with_header(combo.mat, file.path(figure.data.dir, "Fig1G.txt"), 
  header = "Data corresponding to Figure 1G. The upper triangle
  contains genetic correlations. The lower triangle contains trait
  correlations, and the diagonal contains trait heritabilities.")


pdf(here("Results", "Paper", "Fig1G.pdf"), width = 5, height = 3.8)
#png(here("Results", "Paper", "Fig1G.png"), width = 5, height = 3.8, units = "in", res = 300)
layout.mat <- matrix(c(1,2,1,3,1,4), byrow = TRUE, ncol = 2)
layout(layout.mat, widths = c(1, 0.2))
par(mar = c(6,1,1,8), bg = NA)
imageWithText(mat = combo.mat, class.mat = cor.class, show.text = FALSE,
  col.scale = cor.class.cols, grad.dir = "high", 
  row.text.shift = -1.035, row.text.adj = 0, col.text.shift = 0.03,
  color.fun = "exponential", exp.steepness = 1e-6)

#highlight the diagonal
for(i in 1:ncol(pheno.cor)){
  draw.rectangle(min.x = i-0.5, max.x = i+0.5, 
    min.y = (ncol(genetic.cor) - (i-1.5)), 
    max.y = (ncol(genetic.cor)-(i-0.5)))
}

if(highlight.clusters){
  #highlight clusters
  num.cl <- max(trait.cl)
  for(i in 1:num.cl){
    cl.idx <- which(trait.cl[trait.order] == i)
    min.cl <- min(cl.idx)
    max.cl <- max(cl.idx)
    draw.rectangle(min.x = min.cl-0.5, max.x = max.cl+0.5,
      min.y = ncol(genetic.cor) - (min.cl-1.5), 
      max.y = ncol(genetic.cor)-(max.cl-0.5))
  }
}

par(mar = c(1,2,4,3))
imageWithTextColorbar(genetic.cor, col.scale = cor.class.cols[1], 
  grad.dir = "high", cex = 1, global.color.scale = TRUE, 
  global.min = 0, global.max = 1,
  color.fun = "exponential", exp.steepness = 1e-6)
mtext("Genetic\nCorrelation", side = 3, cex = 0.7, line = 0.8)
par(mar = c(1,2,4,3))
imageWithTextColorbar(pheno.cor, col.scale = cor.class.cols[2], 
  grad.dir = "high", cex = 1, global.color.scale = TRUE, 
  global.min = 0, global.max = 1,
  color.fun = "exponential", exp.steepness = 1e-6)
mtext("Phenotype\nCorrelation", side = 3, cex = 0.7, line = 0.8)
par(mar = c(1,2,4,3))
imageWithTextColorbar(mat = matrix(as.numeric(herit), ncol = 1), 
  col.scale = cor.class.cols[3], grad.dir = "high", cex = 1,
  global.color.scale = TRUE, global.min = 0, global.max = 1,
  color.fun = "exponential", exp.steepness = 1e-6)
mtext("Heritability", side = 3, cex = 0.7, line = 0.8)
dev.off()


#quartz(width = 5.5, height = 5)
#pdf(here("Results", "Paper", "Fig1G.pdf"), width = 5.5, height = 5)
#pheatmap(pheno.cor, cluster_cols = trait.clust, cluster_rows = trait.clust)
#dev.off()
```

