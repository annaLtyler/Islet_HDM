---
title: "High Dimensional Mediation"
author: Anna L Tyler
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: hide
    collapsed: no
    toc: yes
    toc_float: yes
---

# Introduction
This workflow performs high-dimensional mediation on the 
Attie 500. 

It uses pre-adjusted transcriptomic and phenotypic data
generated in 1.Tissue_Expression.Rmd and 2.Trait_Selection.Rmd

The transcriptomic data have been processed to remove 
predicted genes and pseudogenes. The transript values
have also been adjust to remove the effects of sex 
and DO generation. For a more detailed explanaion,
see 1.Tissue_Expression.Rmd.

The phenotypic data have been pared down to informative,
relatively non-redundant traits. Sex, DO wave, and generation
were all regressed out. A more detailed explanation can 
be found in 2.Trait_Selection.Rmd.

For this workflow there are several parameters to set.
    1. exp.name: will determine the directory in which the results are stored.
    2. merge.tissues: if TRUE, the transcription kernel is an average of 
        all independent tissue kernels.
    3. use.local.imputation: if TRUE uses locally imputed transcript values 
        to generate polygenic risk scores, if FALSE, uses transcripts imputed 
        with full genetic model (local + kinship)
        The full genetic model gives us better concordance with DO phenotypes,
        but we can't use kinship in the model if we are going to predict phenotypes
        in other populations, like inbred founders, or the CC-RIX.
        This is now set to TRUE by default because we are using a different 
        imputation model that only allows us to impute the locally controlled
        portion of transcription for individuals.


```{r get_args}
rm(list = ls()) #clear out R environment
#args <- commandArgs(trailingOnly=T)
num.perm = 1000

args <- c(1,1,0,1,0) #merged tissues, local imputation, mediation model
#args <- c(1,0,0,1,0) #merged tissues, full imputation, mediation model
#args <- c(0,0,0,1,0) #sep tissues, full imputation, mediation model

#args <- c(1,1,1,1,0) #merged tissues, local imputation, mediation mode, weight adjusted

merge.tissues <- as.logical(args[1]) #if TRUE tissue transcriptome kernels are averaged. Otherwise they are used separtely
use.local.imputation <- TRUE #if TRUE, locally imputed transcripts are used to generate polytranscriptomic risk scores. Otherwise transcripts imputed with the full genetic model are used.
weight.adjusted <- as.logical(args[3]) #if TRUE, body weight is adjusted out of the phenotypes and transcriptome before running mediation
complete.mediation <- as.logical(args[4]) #if TRUE use a mediation network. If FALSE use a reactive network
delete_previous <- as.logical(args[5]) #if TRUE, previous results are overwritten

kinship.effect.only <- FALSE #if TRUE, locally imputed gene expression is 
                            #subtracted from the full model imputation to 
                            #give gene expression imputed only from kinship

#kinship.type = c("germline", "functional") 
kinship.type = "germline" #The germline kinship matrix is the 
                            #standard kinship matrix generated from genotype data.
                            #the functional kinship matrix is a kinship matrix 
                            #generated from the locally imputed transcripts. This
                            #captures the part of the genome that is locally 
                            #controlling gene expression at the time of measurement.


if(is.na(merge.tissues)){stop("Please set the parameters for this run.")}
if(use.local.imputation){
    kinship.effect.only <- FALSE
}

#hdm options
merge.text.options <- c("tissue_sep", "tissue_together")
weight.options <- c("_", "weight_adjusted")
mediation.options <- c("reactive", "complete_mediation")

#permutation options
perm.mat <- "mediator" #either permute the mediator matrix,
#perm.mat <- "kin"      #or the kinshp matrix
if(perm.mat == "mediator"){perm.text = "Permuting the mediator matrix."}
if(perm.mat == "kin"){perm.text = "Permuting the kinshp matrix."}

merge.text <- merge.text.options[(as.numeric(merge.tissues)+1)]
weight.text <- weight.options[(as.numeric(weight.adjusted)+1)]
mediation.text <- mediation.options[(as.numeric(complete.mediation)+1)]
kinship.type.text <- kinship.type

exp.name <- paste(merge.text, weight.text, mediation.text, 
    paste(kinship.type.text, "kinship", sep = "_"), sep = "-")

if(merge.tissues){
    max.tx <- 1
}else{
    max.tx <- length(tissue.names)
}


adjust_before_fitting = NULL
#adjust_before_fitting = "Model_Scores_0.RDS" #we can look for higher dimensions
                            #of effects by adjusting for previous fitted models.
                            #This parameter specifies the name of the fit model
                            #scores to use for the adjustment.
                            #set to NULL to fit the original model
if(!is.null(adjust_before_fitting)){
    adjust.file <- here("Results", "DO", "High_Dim_Med_no_MGE", exp.name, adjust_before_fitting)
    check.file <- file.exists(adjust.file)
    if(!check.file){stop("Error in parameter: adjust_before_fitting\nThe model must be fit before the adjustment.")}
    model_scores <- readRDS(adjust.file)
}

```

This run had the following settings:

* Tissue treatment: `r merge.text`
* Weight adjustment: `r weight.text`
* Mediation type: `r mediation.text`
* Kinship type: `r kinship.type.text`
* Permutation type: `r perm.text`


```{r load_code}
is.interactive = FALSE
#is.interactive = TRUE
library("here")

results.dir <- here("Results", "DO", "High_Dim_Med_no_MGE", exp.name)
if(!file.exists(results.dir)){dir.create(results.dir, recursive = TRUE)}

parsed.data.dir <- here("Results", "DO", "Data") #a results folder that holds parsed data that we don't want to mix in with downloaded data

all.fun <- list.files(here("Code"), full.names = TRUE, pattern = ".R")
for(i in 1:length(all.fun)){source(all.fun[i])}

```

```{r load_libraries, message = FALSE, warning = FALSE, error = FALSE}
all.packages <- c("pheatmap", "qtl2", "gprofiler2", "Matrix", "RGCCA", 
    "bnstruct", "igraph", "corpcor", "cluster", "RColorBrewer",
    "grid", "wordcloud", "stringr", "hexbin", "vioplot")
load_libraries(all.packages, personal.library = TRUE)
```

# High-Dimensional Mediation

## Data

Data were generated through a collaboration between the Attie
lab at the University of Wisconsin, and The Jackson Laboratory.
Detailed descriptions of mouse handling, phenotype gathering,
and initial data processing can be found elsewhere. 

Here we focus use transcriptomic data from five tissues: 
adipose, heart, islet, liver, and skeletal muscle.

I downloaded the following data from the 
[DO QTL viewer](https://churchilllab.jax.org/qtlviewer/attie/DO500HFD)
On March 20, 2023.

1. Adipose.RDS - adipose tissue transcriptome
2. Heart.RDS - cardiac muscle transcriptome
3. Islet.RDS - pancreatic islet transcriptome
4. Liver.RDS - liver transcriptome
5. QTLViewer_Geno_V10.Rdata - Genotypes for mice
6. SkeletalMuscle.RDS - skeletal muscle transcriptome
7. Clinical_Phenotypes_V11.RDS - clinical phenotypes for the Attie 500

The initial results from Isabela are in 
Results > Isabelas_Results. They are also stored in a Dropbox 
folder that Gary shared with me. 

```{r read_transcriptomes}
#read in transcriptomes processed by 1.Tissue_Expression.Rmd
#these are rank Z normalized and adjusted, but not mean centered and scaled.
adj.expr <- readRDS(file.path(parsed.data.dir, "Tissue_Expression_Adjusted.RDS")) #generated by 1a.Tissue_Expression.Rmd
tissue.names <- names(adj.expr)
tissue.cols <- c("orange", "#8dd3c7", "tan", "brown") #colors that are not related to the DO/CC colors
load(here("Data", "DO", "QTLViewer_Geno_V10.Rdata")) #ensembl.version, genoprobs, K, map, markers
covar <- readRDS(file.path(parsed.data.dir, "Clinical_Phenotype_Covariates.RDS")) #generated by 1b.Trait_Selection.Rmd
gene.tables <- readRDS(file.path(parsed.data.dir, "Gene_Tables.RDS")) #generated by 1a.Tissue_Expression.Rmd

#lod tables
tissue.data.file <- lapply(tissue.names, 
  function(x) get.files(here("Data", "DO"), want = x, 
    dont.want = "vivo", full.names = FALSE))
tissue.lod <- lapply(tissue.data.file, 
    function(x) readRDS(here("Data", "DO", x))$lod.peaks$additive)
names(tissue.lod) <- tissue.names

```

## Read clinical phenotypes

Read in clinical phenotypes. These were rank normalized, 
adjusted for sex and DO generation, and then mean centered
and standardized in 1a.Trait_Selection.Rmd

```{r pheno}
scaled.pheno <- readRDS(file.path(parsed.data.dir, "Clinical_Phenotypes_Adjusted.RDS")) #Generated by 1a.Trait_Selection.Rmd
```

## Kinship matrix

```{r germline_kin}

#calculate the germline regardless of which kinship 
#type we have specified. If we have specified the 
#functional kinship, we will compare it to the 
#germline kinship.

kin.file <- file.path(parsed.data.dir, "overall.kinship.RDS")
if(!file.exists(kin.file)){
    Kg = calc_kinship(genoprobs, "overall")
    saveRDS(Kg, kin.file)
}else{
    Kg <- readRDS(kin.file)
}

```

Subset and center kinship matrix based on DO generation.
Make separate matrices for each tissue, because each tissue
has different individuals in it.

```{r subset}
gen.col <- grep("Generation", colnames(covar))
do_gen <- lapply(adj.expr, function(x) covar[rownames(x),gen.col])
gen_cent = lapply(do_gen, function(x) x %*% Diagonal(dim(x)[2], 1 / colSums(x)) %*% t(x)) # Centering matrix

common.ind <- lapply(1:length(gen_cent), function(x) intersect(rownames(gen_cent[[x]]), rownames(Kg)))

#subset kinship matrix to match the individuals in each tissue.
#remove DO generation from kinship matrix
Kg_sub = lapply(1:length(gen_cent), function(x) Kg[common.ind[[x]], common.ind[[x]]])
cent_sub <- lapply(1:length(gen_cent), function(x) gen_cent[[x]][common.ind[[x]], common.ind[[x]]])
Kg_cent = lapply(1:length(gen_cent), function(x) Kg_sub[[x]] - cent_sub[[x]] %*% Kg_sub[[x]] - Kg_sub[[x]] %*% cent_sub[[x]] + cent_sub[[x]] %*% Kg_sub[[x]] %*% cent_sub[[x]])
```

## Process transcriptome

Before kernelizing, remove the effects of the
local eQTLs from each transcript. This will 
ensure that none of the local eQTL information
is in the transcriptomic kernel.

After removing the local eQTL effects, mean center 
and standardize residual transcriptome. 

The phenotypes are already mean centered and scaled.

```{r remove_local_effects, eval = FALSE}
#we are removing this for now. 
#We can use it again later it we decide this is better.

residual.expr.files <- sapply(tissue.names, function(x) file.path(parsed.data.dir, 
    paste0(x, "_Residual.RDS")))

for(tx in 1:length(tissue.names)){
    if(!file.exists(residual.expr.files[tx])){
        tx.expr <- adj.expr[[tx]]
        resid.tx  <- matrix(NA, nrow = nrow(tx.expr), ncol = ncol(tx.expr))
        dimnames(resid.tx) <- dimnames(tx.expr)
        gene.info <- gene.tables[[tx]]
        for(ts in 1:ncol(tx.expr)){
            report.progress(ts, ncol(tx.expr))
            nearest.marker <- gene.info$nearest.marker.id[which(gene.info$gene.id == colnames(tx.expr)[ts])]
            if(nearest.marker == ""){next()}
            nearest.geno <- pull_genoprobpos(genoprobs, marker = nearest.marker)
            model <- fit1(nearest.geno, tx.expr[,ts], kinship = Kg)
            resid.tx[,ts] <- model$resid
        }
        saveRDS(resid.tx, residual.expr.files[tx])
     }
}
residual.expr <- lapply(residual.expr.files, readRDS)

#remove any transcripts that were skipped
for(tx in 1:length(tissue.names)){
    na.idx <- which(apply(residual.expr[[tx]], 2, function(x) all(is.na(x))))
    to.keep <- setdiff(1:ncol(residual.expr[[tx]]), na.idx)
    residual.expr[[tx]] <- residual.expr[[tx]][,to.keep]
}
```

```{r bypass_regress}
#this code bypasses the removal of the local effect of genotype
#in the above code chunk
residual.expr <- adj.expr
```

```{r scale}

#use the residual expression to build the kernel
scaled.expr <- lapply(residual.expr, function(x) apply(x, 2, scale))
#add back the rownames that scaling removes
for(i in 1:length(scaled.expr)){
    rownames(scaled.expr[[i]]) <- rownames(adj.expr[[i]])
}
```

## Build transcriptomic kernel

```{r kernelize}
if(!is.null(adjust_before_fitting)){
    reg.expr <- lapply(scaled.expr, function(x) adjust(x, model_scores[[1]][,"Mediator",drop=F]))
}else{
    reg.expr <- scaled.expr
}
Kt <- lapply(reg.expr, function(x) x %*% t(x) / dim(x)[2])


if(merge.tissues){
    #make a single Kt matrix that is the average of all expression kernels
    #it is repeated for all tissues, so we don't need to change the structure
    #of the analysis
    #This will represent the structure of expression across all tissues
    common.ind <- Reduce("intersect", lapply(Kt, rownames))
    total.Kt <- Reduce("+", lapply(Kt, function(x) x[common.ind, common.ind]))
    Kt <- lapply(1:length(tissue.names), function(x) total.Kt/length(tissue.names))
    names(Kt) <- tissue.names
}
```

## Build phenotype kernel

The plot below shows where there are missing values in the
phenotype matrix. Red indicates missing, blue indicates a filled
cell. There are a few individuals that are missing a few entries. 
They are not concentrated in any particular generation or sex.

```{r pheno_missing}
common.ind <- intersect(rownames(Kt[[1]]), rownames(scaled.pheno))

#select a subset of phenotypes if desired
#sub.pheno <- scaled.pheno[,c("ins_final", "Glu_tAUC", "Ins_tAUC", "HOMA_B", "HOMA_IR")] #chr 11-related
#sub.pheno <- scaled.pheno[,c("weight_final", "food_ave", "TG_6", "TG_10", "TG_14", "TG_final", "Chol_PC1", "Chol_PC2", "Chol_PC3", "Chol_PC4", "leptin", "adiponectin", "fat_pad_weight", "adiposity")] #fat-related traits
#sub.pheno <- scaled.pheno[,c("TG_6wk", "TG_10wk", "TG_14wk")]
sub.pheno <- scaled.pheno[common.ind,]

pheno.missing <- matrix(0, nrow = nrow(sub.pheno), ncol = ncol(sub.pheno))
pheno.missing[which(is.na(sub.pheno))] <- 1
pheatmap(pheno.missing, main = "Missing Values")

missing.ind <- which(rowSums(pheno.missing) > 0)
ismissing <- rep(0, nrow(sub.pheno))
ismissing[missing.ind] <- 1

#par(mfrow = c(3,3))
pval <- rep(NA, ncol(covar))
for(i in 1:ncol(covar)){
    cont.table <- table(data.frame(cbind(ismissing, covar[common.ind,i])))
    #barplot(cont.table, beside = TRUE)
    sig.test <- fisher.test(cont.table)
    pval[i] <- sig.test$p.value
}
barplot(-log10(pval), names = colnames(covar), las = 2, ylab = "-log10(pval)",
main = "-log10(pval) for Fisher exact test\non missingness contingency table")
```

```{r pheno_kernel}
#there are a few missing values. Impute these
sub.pheno <- knn.impute(sub.pheno)

if(!is.null(adjust_before_fitting)){
    reg.pheno <- adjust(sub.pheno, model_scores[[1]][,"Outcome", drop=FALSE])
}else{
    reg.pheno <- sub.pheno
}
Kp <- reg.pheno %*% t(reg.pheno) / dim(reg.pheno)[2]
```

## Perform high-dimensional mediation

```{r mediation}

if(!is.null(adjust_before_fitting)){
    adjust_numeral <- as.numeric(gsub(".RDS", "", strsplit(basename(adjust.file), "_")[[1]][3])) + 1
}else{
    adjust_numeral  <- 0
}

transcript_loading_file <- file.path(results.dir, paste0("Loadings_Transcripts_", adjust_numeral, ".RDS"))
trait_loading_file <- file.path(results.dir, paste0("Loadings_Traits_", adjust_numeral, ".RDS"))
marker_loading_file <- file.path(results.dir, paste0("Loadings_Markers_", adjust_numeral, ".RDS"))
model_file <- file.path(results.dir, paste0("Model_Scores_", adjust_numeral, ".RDS"))

if(!file.exists(transcript_loading_file) || delete_previous){
    transcript_loadings <- trait_loadings <- model_scores <- vector(mode = "list", length = length(tissue.names))
    names(transcript_loadings) <- names(trait_loadings) <- names(model_scores) <- tissue.names
    flags <- rep(NA, length(tissue.names))
    stopping.reasons <- rep(NA, length(tissue.names))
    for(tx in 1:length(tissue.names)){
        if(is.interactive){cat("\n", tissue.names[tx], "\n")}
        
        #assign matrices to proper positions
        if(complete.mediation){
            #transcripts are the mediator
            mediator.kernel = Kt[[tx]]; transcript.col <- "Mediator"
            #phenotypes are the outcome
            outcome.kernel = Kp; trait.col <- "Outcome"
        }else{
            #phenotypes are the mediator
            mediator.kernel = Kp;trait.col <- "Mediator" 
            #transcripts are the outcome
            outcome.kernel = Kt[[tx]]; transcript.col = "Outcome" 
        }
        
        fit.result <- high_dim_med(causal.matrix = Kg_cent[[tx]], 
            mediating.matrix = mediator.kernel, outcome.matrix = outcome.kernel, 
            min.weight.diff = 1e-5, max.iter = 15, scheme = "centroid", 
            verbose = is.interactive, kernel.c = TRUE, kernel.m = TRUE, 
            kernel.o = TRUE)

        #test <- scan1(genoprobs, fit.result[[1]][,2])
        #plot(test, map = map)

        model_scores[[tx]] <- fit.result[[1]]
        flags[tx] <- fit.result[[2]]
        stopping.reasons[tx] <- fit.result[[3]]

        #calculate the trait loadings. This is the 
        #correlation between the scaled phenotype
        #and the phenotype score found by the model
        trait_cor <- calc_loadings(scores = model_scores[[tx]][,trait.col,drop = FALSE], 
            data.mat = sub.pheno)
        

        #if the traits are mostly negatively correlated with 
        #the scores, multiply the model scores by -1
        #and recalculate
        if(mean(trait_cor) < 0){
            model_scores[[tx]] <- model_scores[[tx]] * -1
            trait_cor <- calc_loadings(model_scores[[tx]][,trait.col,drop = FALSE], 
                sub.pheno)
        }
        trait_loadings[[tx]] <- t(trait_cor)
    
        #calculate transcript loadings
        #This is the correlation between the scaled expression
        #and the transcript score found by the model
        tx_load <- calc_loadings(model_scores[[tx]][,transcript.col,drop = FALSE], 
            scaled.expr[[tx]])
        transcript_loadings[[tx]] <- t(tx_load)
        }

    saveRDS(transcript_loadings, transcript_loading_file)
    saveRDS(trait_loadings, trait_loading_file)
    saveRDS(model_scores, model_file)
}else{
    transcript_loadings <- readRDS(transcript_loading_file)
    trait_loadings <- readRDS(trait_loading_file)
    model_scores <- readRDS(model_file)
}
```


```{r mediate, eval = FALSE}

stop()

trait.herit <- as.numeric(est_herit(scaled.pheno[,"HOMA_B"], Kg))
trait.scan <- scan1(genoprobs, scaled.pheno[,"HOMA_B"])
trait.peak <- find_peaks(trait.scan, map = map, threshold = 7)
best.marker <- pull_genoprobpos(genoprobs, map = map, chr = trait.peak[1,"chr"], pos = trait.peak[1,"pos"])

one.fit <- fit1(best.marker, scaled.pheno[,"HOMA_B"])
common.ind <- intersect(rownames(scaled.pheno), rownames(best.marker))
plot.with.model(scaled.pheno[common.ind,"HOMA_B"], one.fit$fitted[common.ind])
var(one.fit$fitted)
as.numeric(est_herit(one.fit$resid, Kg))

test.scan <- scan1(genoprobs, scaled.pheno)
#test.scan <- scan1(genoprobs, model_scores[[1]])


pdf("~/Desktop/test.pdf", width = 10, height = 5)
for(i in 1:ncol(test.scan)){
    plot(test.scan, map = map, lodcol = i, main = colnames(test.scan)[i])
}
dev.off()


adj.scan <- scan1(genoprobs, scaled.pheno, addcovar = model_scores[[2]][,"Mediator"])
#adj.scan <- scan1(genoprobs, model_scores[[1]][,"Outcome"], addcovar = model_scores[[2]][,"Mediator"])
#adj.scan <- scan1(genoprobs, model_scores[[1]][,"Mediator"], addcovar = model_scores[[2]][,"Outcome"])

pdf("~/Desktop/test_adj.pdf", width = 10, height = 5)
for(i in 1:ncol(adj.scan)){
    maxy <- max(c(test.scan[,i], adj.scan[,i]))*1.2
    plot(test.scan, map = map, lodcol = i, main = colnames(adj.scan)[i], ylim = c(0, maxy))
    plot(adj.scan, map = map, lodcol = i, main = colnames(adj.scan)[i], add = TRUE, col = "red")
    
    #plot(test.scan, map = map, lodcol = "Outcome", main = colnames(adj.scan)[i], ylim = c(0, 10))
    #plot(adj.scan, map = map, lodcol = 1, main = colnames(adj.scan)[i], add = TRUE, col = "red")
}
dev.off()


pheno.scan <- scan1(genoprobs, model_scores[[1]][,3])
mediator.scan <- scan1(genoprobs, model_scores[[1]][,2])
geno.scan <- scan1(genoprobs, model_scores[[1]][,1])

pdf("Mapped_scores.pdf", width = 10, height = 5)
plot(pheno.scan, map = map, main = "Phenotype Score")
plot(mediator.scan, map = map, main = "Mediator Score")
plot(geno.scan, map = map, main = "Genome Score")
dev.off()
```

## Causal Networks {.tabset .tabset-fade .tabset-pills}

The following plot shows the partial correlations between
the causal factor, the mediator, and the outcome. Line
width corresponds to partial correlation, and line color
corresponds with the sign of the partial correlation. Orange
is negative and green is positive.

If the tissues were run separately, there will be one plot
per tissue. Otherwise, there will be just one plot for all tissues.

```{r plot_nets, results = "asis"}
for(tx in 1:max.tx){
 if(max.tx == 1){
        cat("### All Tissues\n")
    }else{
        cat("###", tissue.names[tx], "\n")
    }    
    tx.pcor <- pcor.shrink(model_scores[[tx]], verbose = FALSE)
    tx.pcor[lower.tri(tx.pcor, diag = TRUE)] <- 0
    net <- graph_from_adjacency_matrix(tx.pcor, weighted = TRUE, mode = "directed")
    e.weight <- E(net)$weight
    plot(net, edge.width = abs(e.weight*10), edge.color = sign(e.weight)+2, 
        layout = layout_on_grid, edge.label = signif(e.weight, 2),
        edge.label.cex = 1.5, vertex.size = 30)
    if(max.tx > 1){
        cat("\n\n")
    }
}
```

## Permutations {.tabset .tabset-fade .tabset-pills}

Run permutations to calulate a null distribution for the path
coefficient. This is the correlation between the causal matrix 
and the outcome matrix. To do this, we shuffle the names of the 
mediator kernel. 

This decorrelates the 


```{r perm}
perm.file <- file.path(results.dir, 
    paste0("Permuted_Stats_", perm.mat, "_permuted_", adjust_numeral, ".RDS")) #holds permuted path coefficients and partial correlations between components
null.mediator.file <- file.path(results.dir, 
    paste0("Permuted_Mediator_Scores_", perm.mat, "_permuted_", adjust_numeral, ".RDS")) #holds permuted mediator scores, which can be used to calculate null transcript loadings

if(!file.exists(perm.file) || delete_previous){

    all.perms <- vector(mode = "list", length = max.tx)
    null.mediator.scores <- vector(mode = "list", length = max.tx)

    for(tx in 1:max.tx){

        if(complete.mediation){
            #for the mediation model, the transcript kernel is the mediator
            mediator.kernel = Kt[[tx]]
            outcome.kernel = Kp
        }else{
            #for the reactive model, the phenotype is the mediator
            mediator.kernel = Kp
            outcome.kernel = Kt[[tx]]
        }
        
        perm_stats <- matrix(NA, nrow = num.perm, ncol = 4)
        colnames(perm_stats) <- c("path_coef", "X-M", "M-Y", "X-Y")
        null.med.mat <- matrix(NA, nrow = nrow(mediator.kernel), ncol = num.perm)        
        rownames(null.med.mat) <- rownames(mediator.kernel)

        for(p in 1:num.perm){

            if(is.interactive){report.progress(p, num.perm)}
            
            if(perm.mat == "mediator"){
                #permute the mediator
                perm_names <- sample(rownames(mediator.kernel))
                perm_mediator <- mediator.kernel
                rownames(perm_mediator) <- colnames(perm_mediator) <- perm_names
           
                perm_scores <- high_dim_med(causal.matrix = Kg_cent[[tx]], 
                    mediating.matrix = perm_mediator, outcome.matrix = outcome.kernel, 
                    min.weight.diff = 1e-5, max.iter = 15, scheme = "centroid", 
                    verbose = FALSE, kernel.c = TRUE, kernel.m = TRUE, 
                    kernel.o = TRUE)
            }
            if(perm.mat == "kin"){
                #permute the mediator
                perm_names <- sample(rownames(Kg_cent[[tx]]))
                perm_kin <- Kg_cent[[tx]][perm_names, perm_names]
                rownames(perm_kin) <- colnames(perm_kin) <- rownames(Kg_cent[[tx]])

                perm_scores <- high_dim_med(causal.matrix = perm_kin, 
                    mediating.matrix = mediator.kernel, outcome.matrix = outcome.kernel, 
                    min.weight.diff = 1e-5, max.iter = 15, scheme = "centroid", 
                    verbose = FALSE, kernel.c = TRUE, kernel.m = TRUE, 
                    kernel.o = TRUE)
            }
        
            #keep mediator model scores
            null.med.mat[,p] <- perm_scores[[1]][,"Mediator"]
            #keep stats
            perm_stats[p,] <- path_coef(perm_scores[[1]])
        }

    all.perms[[tx]] <- perm_stats
    null.mediator.scores[[tx]] <- null.med.mat
    }

    saveRDS(all.perms, perm.file)
    saveRDS(null.mediator.scores, null.mediator.file)

}else{
    all.perms <- readRDS(perm.file)
    null.mediator.scores <- readRDS(null.mediator.file)
}

```

The following plots show null distributions of the path 
coefficient for each tissue, unless tissues were merged, 
and then only one set of null distribution is shown. 

The dot plot shows the relationship between the X-M 
correlation and the M-Y correlation. The permutations 
show that you can make one of them quite high, but 
getting both high is very difficult and can only be 
done with the true data.

The histogram shows the null distribution of the path
coefficient along with the observed path coeffient.
The observed path coefficient is well outside the 
null distribution.

```{r plot_perm, results = "asis", fig.height = 5, fig.width = 5}

for(tx in 1:max.tx){
    if(max.tx == 1){
        cat("### All Tissues\n")
    }else{
        cat("###", tissue.names[tx], "\n")
    }
    
    tissue.path.stats <- path_coef(model_scores[[tx]])
    tissue.path.coef <- tissue.path.stats[1]

    axis.max <- max(c(all.perms[[tx]][,c("X-M", "M-Y")], tissue.path.stats[c("X-M", "M-Y")]), na.rm = TRUE)
    axis.min <- min(c(all.perms[[tx]][,c("X-M", "M-Y")], tissue.path.stats[c("X-M", "M-Y")]), na.rm = TRUE)

    plot(all.perms[[tx]][,"X-M"], all.perms[[tx]][,"M-Y"], xlim = c(axis.min, axis.max), 
        ylim = c(axis.min, axis.max), xlab = "X-M correlation", ylab = "M-Y correlation")
    points(tissue.path.stats["X-M"], tissue.path.stats["M-Y"], 
        col = "red", pch = 16)
    abline(0,1)

    path.min <- min(c(all.perms[[tx]][,"path_coef"], tissue.path.coef), na.rm = TRUE)
    path.max <- max(c(all.perms[[tx]][,"path_coef"], tissue.path.coef), na.rm = TRUE)
    hist(all.perms[[tx]][,"path_coef"], xlim = c(path.min, path.max), 
        main = "Path Coef. Permutations", xlab = "", breaks = 100)
    abline(v = tissue.path.coef, col = "red")

    cat("\n\n")
}
```

We also looked at the null distributions of transcript
loadings. It would be interesting to be able to select
transcripts with "significant" loadings in each tissue.
However, the following plots show that most observed 
transcript loadings are well outside the null distribution,
so there is no cutoff that gives us a few transcripts to 
analyze.

This code takes a long time to run, the null files are
huge, and I've seen enough examples, that I don't need
to keep running this. I am shutting off the code with 
a flag that can be turned back on to calculate the 
null loadings. 

**Note about imputations:** We have found after lots of digging
that the Bayesian method of imputing transcripts with local
and distal components is not working. It is merging the local
and distal signals so that they are highly correlated. We
are now doing the simplest possible imputation, which is the
fitted values from the fit1 mixed model using kinship as a
random effect. This procedure is performed in 3b.Imputation.Rmd. 
To calculate the variance explained by the distal component of 
each transcript, we calculate the variance and heritability of
the residuals of that fit1 model. The variance of the residuals
is the amount of transcript variance that is explained by distal
factors and error. By calculating the heritability of the residuals,
we can estimate the proportion of the residual variance that is
due to distal factors. We are implementing that to replace the Bayesian 
imputations we tried earlier.

```{r prep_pop}
calc_null <- FALSE #set to TRUE to calculate null loading
```

```{r load_herit}
#These imputed transcripts are the fitted values from fit1 
#with the nearest marker and a kinship correction
#created by 3b.Imputation.Rmd
imp.files <- list.files(here("Results", "DO", "Imputed_Transcriptomes"), pattern = "Local", full.names = TRUE)
tissue.imp.gen <- lapply(imp.files, readRDS)
#local.var.exp <- lapply(tissue.imp.gen, function(x) apply(x, 2, var))

#also read in distal components of heritability
#created by 3b.Imputation.Rmd
distal.files <- list.files(here("Results", "DO", "Imputed_Transcriptomes"), pattern = "Distal", full.names = TRUE)
distal.var <- lapply(distal.files, readRDS)

names(distal.var) <- names(tissue.imp.gen) <- tissue.names

#calculate the variance explained by the distal component for each transcript
local.var.exp <- lapply(distal.var, function(x) x[,"local_var"])
dist.var.exp <- lapply(distal.var, function(x) x[,"residual_variance"]*x[,"residual_heritability"])

#trait correlation files
trait.cor.files <- list.files(here("Results", "DO", "Transcriptomes"), 
    pattern = "Maximum_Trait_Correlation", full.names = TRUE) #generated in 2a.Kinship_Expression_Traits.Rmd
trait.cor <- lapply(trait.cor.files, readRDS)
names(trait.cor) <- tissue.names

```

## Latent Variable Correlations {.tabset .tabset-fade .tabset-pills}

The following plots show the partial correlations between 
the pairs of scores for all model scores. With perfect 
mediation of X -> M -> Y, the partial correlation between 
X and Y should be 0. We get pretty close here.

```{r plot_cor, results = "asis", fig.height = 6, fig.width = 6}
#pdf("~/Desktop/test.pdf")
for(tx in 1:length(tissue.names)){
    cat("###", tissue.names[tx], "\n")
    #find the correlations between the scores
    curr_scores <- model_scores[[tx]]
    
    #change from generic names to specific names
    if(complete.mediation){
        colnames(curr_scores) <- c("Genome", "Transcriptome", "Traits")
    }else{
        colnames(curr_scores) <- c("Genome", "Traits", "Transcriptome")
    }
    
    path.coef <- path_coef(curr_scores)

    all.pairs <- pair.matrix(1:ncol(curr_scores))
    adj.var <- apply(all.pairs, 1, function(x) setdiff(1:3, x))
    #pdf("~/Desktop/test.pdf") 
    par(mfrow = c(2,2))
    for(i in 1:nrow(all.pairs)){
        var1 <- all.pairs[i,1]
        var2 <- all.pairs[i,2]
        adj.by <- adj.var[i]
        plot.with.model(adjust(curr_scores[,var1,drop=FALSE], curr_scores[,adj.by,drop=FALSE]), 
            adjust(curr_scores[,var2,drop=FALSE], curr_scores[,adj.by,drop=FALSE]),
            xlab = colnames(curr_scores)[all.pairs[i,1]], 
            ylab = colnames(curr_scores)[all.pairs[i,2]], report = "cor.test")
    }
    #test <- check_signs(curr_scores)
    #pairs(test[[1]])

    #pairs(curr_scores, main = paste(tissue.names[tx], "\nPath  Coef:", round(path.coef, 3)))
    cat("\n\n")
}
#dev.off()
```

# Transcript Loadings

The following plot shows the distributions of transcript
loadings across the tissues. Adipose tissue has the largest
magnitude loadings in both directions suggesting that transcripts
in the adipose tissue are stronger mediators of genetic effects
on traits than transcripts in the other tissues.

```{r loading_vio}
vioplot(transcript_loadings, col = tissue.cols)
abline(h = 0)
```


The following plots show more detail of these distributions.

```{r loading_dist, fig.height = 8, fig.width = 8}

par(mfrow = c(2,2))
for(tx in 1:length(tissue.names)){
    hist(transcript_loadings[[tx]], breaks = 100, xlab = "Loading",
    main = tissue.names[tx])
}
```

## Transcript Loadings and Heritability

We are interested in how local and distal heritability
of transcripts relates to their trait relevance. 

We showed in 3a.Imputation.Rmd that local heritability is
negatively correlated with maximum trait correlation. 

Transcript loading is another measure of trait relevance.
However, transcript loading also has heritability baked
into it, so it should be more positively correlated with 
both local and distal variance explained than simple trait 
correlation.


### Loading vs. Maximum Trait Correlation {.tabset .tabset-fade .tabset-pills}

Maximum trait correlation is our measure of trait 
relevance. Transcript loading is another measure
of trait relevance, thus maximum trait correlation 
and transcript loading should be positively correlated. 
However, transcript loading also has heritability
baked into it, so the importance of transcripts can
be up- or down-graded based on how heritable they 
are.

The following plots show the relationship between
maximum trait correlation and transcript loading.
They are highly correlated, particularly for 
adipose tissue.

```{r loading_cor, fig.height = 5, fig.width = 5, results = "asis"}
for(tx in 1:length(tissue.names)){
    cat("####", tissue.names[tx], "\n")
    common.tx <- intersect(rownames(transcript_loadings[[tx]]), names(trait.cor[[tx]]))
    plot_with_marginal_hist(abs(trait.cor[[tx]][common.tx]),
        abs(transcript_loadings[[tx]][common.tx,1]),
        ylab = "|Loading|", xlab = "|Max. Trait Correlation|", main = tissue.names[tx])
    cat("\n\n")
}
```

### Loading vs. Local Variance Explained {.tabset .tabset-fade .tabset-pills}

The following plots show the correlation between local variance
explained and trait loading. This relationship is much flatter
than the relationship between local variance explained and
trait correlation. This is likely because transcript loading
has heritability incorporated into it, so it makes the 
correlation a little bit more positive.

```{r local_v_loading, fig.width = 5, fig.height = 5, results = "asis"}

for(tx in 1:length(tissue.names)){
    cat("####", tissue.names[tx], "\n")
    common.ts <- Reduce("intersect", list(rownames(transcript_loadings[[tx]]), 
        names(local.var.exp[[tx]])))
    
    plot_with_marginal_hist(abs(transcript_loadings[[tx]][common.ts,1]),
        local.var.exp[[tx]][common.ts], 
        xlab = "|Loading|", ylab = "Local Variance Explained",
        main = tissue.names[tx], report = "cor.test")
    cat("\n\n")
}
```


### Loading vs. Distal Variance Explained {.tabset .tabset-fade .tabset-pills}

Transcript loading is much more positively correlated to distal
heritability. This is also by construction. The transcript score
is constructed to relate distal heritability to trait relevance.

```{r distal_v_loading, fig.width = 5, fig.height = 5, results = "asis"}

#pdf("~/Desktop/test.pdf", width = 5, height = 4)
for(tx in 1:length(tissue.names)){
    cat("####", tissue.names[tx], "\n")
    common.ts <- Reduce("intersect", list(rownames(transcript_loadings[[tx]]), 
        names(dist.var.exp[[tx]])))
    
    plot_with_marginal_hist(abs(transcript_loadings[[tx]][common.ts,1]),
        dist.var.exp[[tx]][common.ts], 
        xlab = "|Loading|", ylab = "Distal Variance Explained",
        main = tissue.names[tx], report = "cor.test")
    cat("\n\n")
}
#dev.off()
```


```{r calc_null_dist}
if(calc_null){
    null.loading.file <- file.path(results.dir, paste0("Null_Loadings_", perm.mat, "_permuted", ".RDS"))

    if(!file.exists(null.loading.file)){
        null_loadings  <- vector(mode = "list", length = length(transcript_loadings))
        names(null_loadings) <- names(transcript_loadings)

        for(tx in 1:length(transcript_loadings)){
            
            tx.r2 <- apply(tissue.imp.gen[[tx]], 2, var)
            common.transcripts <- intersect(names(tx.r2), rownames(transcript_loadings[[tx]]))

            #calculate null loadings
            if(merge.tissues){
                null_loadings[[tx]] <- sapply(1:ncol(null.mediator.scores[[1]]), 
                    function(x) calc_loadings(null.mediator.scores[[1]][,x,drop=FALSE], 
                    scaled.expr[[tx]]))
                rownames(null_loadings[[tx]]) <- rownames(transcript_loadings[[tx]])
            }else{
                null_loadings[[tx]] <- sapply(1:ncol(null.mediator.scores[[tx]]), 
                    function(x) calc_loadings(null.mediator.scores[[tx]][,x,drop=FALSE], 
                    scaled.expr[[tx]]))
                rownames(null_loadings[[tx]]) <- rownames(transcript_loadings[[tx]])
            }
        }
        saveRDS(null_loadings, null.loading.file)
    }else{
        null_loadings <- readRDS(null.loading.file)
    }
}
```

```{r load_dist, fig.width = 8, fig.height = 8}

if(calc_null){
    all.dens <- c(lapply(transcript_loadings, density), lapply(null_loadings, density))
    xmin <- min(sapply(all.dens, function(x) min(x$x)))
    xmax <- max(sapply(all.dens, function(x) max(x$x)))
    ymax <- max(sapply(all.dens, function(x) max(x$y)))

    par(mfrow = c(2,2))
    for(tx in 1:length(transcript_loadings)){
        plot(density(null_loadings[[tx]]), type = "l", col = "gray", lwd = 3,
            xlim = c(xmin, xmax), ylim = c(0, ymax), xlab = "Loading",
            main = names(transcript_loadings[tx]))
        points(all.dens[[tx]], type = "l", col = tissue.cols[tx], lwd = 3)
        legend("topleft", col = c(tissue.cols[tx], "gray"), legend = c("observed", "null"), 
            lty = 1, lwd = 3)
    }
}
```


## Enrichment of genes with high loadings {.tabset .tabset-fade .tabset-pills}

The following plots show the functional enrichment for 
transcripts at the top and bottom of each list for each 
tissue.

This section also writes out the top and bottom transcripts
for analysis in CMAP.

```{r enrichment}
enrich.file <- file.path(results.dir, paste0("Top_Bottom_Loading_Enrichment_", adjust_numeral, ".RDS"))
hum.mus.ortho <- as.matrix(read.delim(here("Data", "general", "human.mouse.orthologs.txt"), 
    stringsAsFactors = FALSE))

if(!file.exists(enrich.file) || delete_previous){
    all.enrich <- vector(mode = "list", length = length(tissue.names))
    names(all.enrich) <- tissue.names

    top.n <- 150
    for(tx in 1:length(tissue.names)){
        top.genes <- sort(transcript_loadings[[tx]][,1], decreasing = TRUE)[1:top.n]
        top.enrich <- gost(names(top.genes), organism = "mmusculus")
        
        top.hum.id <- mouse_to_human_ensembl(mouse_ensembl = names(top.genes), 
            hum.mus.ortho = hum.mus.ortho)

        bottom.genes <- sort(transcript_loadings[[tx]][,1], decreasing = FALSE)[1:top.n]
        bottom.enrich <- gost(names(bottom.genes), organism = "mmusculus")
        bottom.hum.id <- mouse_to_human_ensembl(mouse_ensembl = names(bottom.genes), 
            hum.mus.ortho = hum.mus.ortho)
        
        cmap.table <- cbind(top.hum.id[,"Human.Entrez"], bottom.hum.id[,"Human.Entrez"])
        colnames(cmap.table) <- c("Positive", "Negative")
        write.table(cmap.table, 
            file.path(results.dir, paste0("CMAP_Transcript_Loadings_", tissue.names[tx], "_", adjust_numeral, ".txt")),
            quote = FALSE, row.names = FALSE, sep = "\t")

        all.enrich[[tx]] <- list("top" = top.enrich, "bottom" = bottom.enrich)
    }
    saveRDS(all.enrich, enrich.file)
}else{
    all.enrich <- readRDS(enrich.file)
}
```

```{r plot_enrichment, results = "asis", fig.width = 10, fig.height = 5, warning = FALSE, message = FALSE}
#pdf("~/Desktop/Enrichment_loading_wordcloud.pdf", width = 20, height = 10)
for(tx in 1:length(tissue.names)){
    cat("###", tissue.names[tx], "{.tabset .tabset-fade .tabset-pills}\n")

    cat("#### Positive Loadings\n")
    par(mfrow = c(1,2))
    plot.enrichment.wordcloud(enrichment = all.enrich[[tx]]$top, 
        order.by = "p_value",
        plot.label = paste(tissue.names[tx], "Positive Loadings"), 
        num.terms = 25, max.term.size = 3000)

    cat("\n\n")

    cat("#### Negative Loadings\n")
    par(mfrow = c(1,2))
    plot.enrichment.wordcloud(all.enrich[[tx]]$bottom, 
        plot.label = paste(tissue.names[tx], "Negative Loadings"), 
        num.terms = 25, max.term.size = 3000)

    cat("\n\n")
}
#dev.off()
```

```{r enrich_tables, eval = FALSE}
pdf("~/Desktop/Loading_Enrichment.pdf", width = 20, height = 9)
for(tx in 1:length(tissue.names)){

    par(mfrow = c(1,2))
    plot.enrichment(enrichment = all.enrich[[tx]]$top, 
        order.by = "p_value",
        plot.label = paste(tissue.names[tx], "Positive Loadings"), 
        num.terms = 25, max.term.size = 3000)

    plot.enrichment(all.enrich[[tx]]$bottom, 
        plot.label = paste(tissue.names[tx], "Negative Loadings"), 
        num.terms = 25, max.term.size = 3000)

    write.table(all.enrich[[tx]]$top$result[,c("term_name", "term_id", "p_value")],
        "~/Desktop/top_enrich.txt", sep = "\t", row.names = FALSE,
        quote = FALSE)

    write.table(all.enrich[[tx]]$bottom$result[,c("term_name", "term_id", "p_value")],
        "~/Desktop/bottom_enrich.txt", sep = "\t", row.names = FALSE, 
        quote = FALSE)

}
dev.off()

```

# Trait loadings

The following plot shows the loadings on traits.
This shows which traits are most affected by the 
genome -> transcriptome path.

```{r trait_loadings, fig.width = 7, fig.height = 7}
all.loadings <- Reduce("cbind", trait_loadings)
colnames(all.loadings) <- tissue.names

#pdf("~/Desktop/test.pdf", width = 7, height = 7)
if(merge.tissues){
    par(mar = c(4, 8, 4, 2))
    barplot(sort(all.loadings[,1]), las = 2, horiz = TRUE, xlab = "Trait Loading")
}else{
    pheatmap(all.loadings)
}
#dev.off()
```

# Polytranscriptomic risk scores

Can we use each animal's transcription profile to predict 
their phenotype? Here, we multiply the transcript loadings
by each individual's transcription profile and calculate the
mean as its predicted position in phenotype space.

## Correlation with phenome score

The following plots show the correlations between phenome score
and the predicted phenome score based on individual transcriptome.

```{r ptrs, fig.width = 8, fig.height = 8}
if(mediation.text == "complete_mediation"){
    transcript.pred <- vector(mode = "list", length = length(tissue.names))
    names(transcript.pred) <- tissue.names

    par(mfrow = c(2,2))
    for(tx in 1:length(tissue.names)){

        tx.idx <- which(names(tissue.imp.gen) == tissue.names[tx])
        if(length(tx.idx) == 0){next()} #we don't have all the tissues imputed yet.

        #calculate a loaded transcript score for every individual
        #this is their measured transcriptome times the loadings.
        #first scale expression across individuals
        ind.scaled.expr <- apply(adj.expr[[tx]], 2, scale)
        dimnames(ind.scaled.expr) <- dimnames(adj.expr[[tx]])
        
        common.tx <- intersect(colnames(ind.scaled.expr), rownames(transcript_loadings[[tx]]))
        transcript.pred[[tx]] <- apply(ind.scaled.expr[,common.tx], 1, function(x) x * transcript_loadings[[tx]][common.tx,])
        mean.pred <- colMeans(transcript.pred[[tx]])
        pred.order <- order(mean.pred)    
        
        common.ind <- intersect(rownames(ind.scaled.expr), rownames(model_scores[[tx]]))
        plot.with.model(mean.pred[common.ind], model_scores[[tx]][,"Outcome"],
            xlab = "Prediction", ylab = "Phenome Score", main = tissue.names[tx])
    }

}
```


## Distributions for individual extremes

The following histograms show the transcriptional profiles of the 
fattest and leanest individuals. Values shown are the loaded transcripts
for an individual indicating whether each transcript is increasing or 
decreasing the individuals obesity. Below the histograms are boxplots 
showing these distributions for the top and bottom individuals based 
on phenome score.


We also plot to pngs matrices showing the proportion of 
obesity-exacerbating (red), and obesity-alleviating (blue) 
transcripts based on their loadings (Risk_Count_tissue_name.png). 
The individuals are sorted by their phenotype score. There are 
proportionally more exacerbating transcripts in the animals with
higher phenotype scores than in those with lower scores.


```{r polygenic_risk_score, warning = FALSE, message = FALSE, fig.width = 8, fig.height = 8}
if(mediation.text == "complete_mediation"){
    pred.mats <- vector(mode = "list", length = length(tissue.names))
    names(pred.mats) <- tissue.names

    for(tx in 1:length(tissue.names)){

        tx.idx <- which(names(tissue.imp.gen) == tissue.names[tx])
        if(length(tx.idx) == 0){next()} #we don't have all the tissues imputed yet.

        #look at the distribution of loaded transcripts for an individual
        #this is for the individual with the lowest phenome score
        #pdf(file.path(results.dir, paste0("Individual_Comparisons_", tissue.names[tx], "_", 
        #    adjust_numeral, ".pdf")), width = 10, height = 10)
        layout(matrix(c(1,2,3,3), nrow = 2, byrow = TRUE))
        phenome.score <- model_scores[[tx]][,"Outcome"]
        sorted.phenome.score <- sort(phenome.score, decreasing = FALSE)
        
        min.ind <- which.min(phenome.score)
        hist(transcript.pred[[tx]][,names(min.ind)], breaks = 100, xlab = "Loaded Transcript",
            main = "Distribution of Loaded Transcripts\nFor Leanest Animal")
        abline(v = mean(transcript.pred[[tx]][,names(min.ind)]), col = "red")

        max.ind <- which.max(phenome.score)
        hist(transcript.pred[[tx]][,names(max.ind)], breaks = 100, xlab = "Loaded Transcript",
            main = "Distribution of Loaded Transcripts\nFor Fattest Animal")
        abline(v = mean(transcript.pred[[tx]][,names(max.ind)]), col = "red")

        leanest <- names(head(sorted.phenome.score, 10))
        fattest <- names(tail(sorted.phenome.score, 10))
        boxplot(cbind(transcript.pred[[tx]][,c(leanest, fattest)]), las = 2, ylab = "Loaded Transcript",
            main = "Comparison of Top and Bottom 10 of Phenotype Distribution")
        abline(h = 0);abline(v = 10.5)
        #dev.off()

        #boxplot(transcript.pred[,common.ind[pheno.order]])
        pred.mat <- matrix(0, nrow = nrow(transcript.pred[[tx]]), ncol = length(phenome.score))
        colnames(pred.mat) <- names(sorted.phenome.score)
        
        pred.mat[which(transcript.pred[[tx]][,names(sorted.phenome.score)] > 0)] <- 1
        sorted.pred <- apply(pred.mat, 2, sort)
        pred.mats[[tx]] <- sorted.pred
    }
}
graphics.off() #make sure all graphics devices are shut off
```

```{r plot_prediction_matrices}
for(tx in 1:length(tissue.names)){
    png(file.path(results.dir, paste0("Risk_Count_", tissue.names[tx], "_", 
        adjust_numeral, ".png")), width = 10, height = 5, units = "in", res = 100)
        pheatmap(sorted.pred, cluster_rows = FALSE, cluster_cols = FALSE, show_rownames = FALSE,
            show_colnames = FALSE)
    dev.off()
}


```

# Tissues of Action

How are transcript loadings distributed across tissues?
High loadings in one tissue tells us the tissue of action 
for individual genes. Are there commonalities across tissues?

The following code generates a clustered heatmap of transcript
loadings across tissues for which each transcript has a z score
of at least 2.5 in at least one of the tissues. It looks for 
functional enrichments in each of the clusters and plots the
results both with quick labels for each cluster, as well as 
more detailed information about the enrichments of each cluster.

The plots are printed to a pdf with the title TOA_Transcript_Loadings.pdf

```{r get_max_enrich}
#This function gets the most significant term out of an
#enrichment table returned from gost.

get_max_enrich <- function(enrichment){
    if(is.null(enrichment)){
        return("no enrichment")
    }
    min.p.idx <- which.min(enrichment[[1]][,"p_value"])
    sig.term <- enrichment[[1]][min.p.idx,"term_name"]
    return(sig.term)
}

#This function takes in a list of loadings.
#The list should consist of named vectors, where the names
#are the transcript names.
#filters them for high values based on the given threshold,
#and clusters into groups. It picks the number of clusters
#that give the best cluster separation in k-means clustering
#It looks for functional enrichments of each cluster, and then
#plots a heatmap of the clusters along with more detailed 
#reports of the enrichment of each.
#z.thresh is the z.score threshold to use for selecting
#transcripts.
cluster_values <- function(value.list, z.thresh = 3, k.seq = 3:20){

    #threshold values above Z score threshold
    scaled.values <- lapply(value.list, rankZ)
    high.values <- lapply(scaled.values, function(x) which(abs(x) > z.thresh))
    all.high <- unique(unlist(lapply(1:length(high.values), function(x) names(value.list[[x]])[high.values[[x]]])))
    all.high.idx <- sapply(value.list, function(x) match(all.high, names(x)))

    #combine into a matrix that contains all unique transcripts
    #above the threshold
    value.mat <- sapply(1:length(value.list), 
        function(x) value.list[[x]][all.high.idx[,x]])
    rownames(value.mat) <- all.high
    colnames(value.mat) <- tissue.names
    #set NAs to 0
    value.mat[which(is.na(value.mat))] <- 0

    #use k-means clustering to figure out how many clusters
    #there are in this matrix. Set the number of clusters to
    #test with k.seq
    test.k <- test.pam.k(value.mat, plot.results = FALSE, kseq = k.seq)
    mean.cl.width <- sapply(test.k$cl.width, mean)
    #barplot(mean.cl.width)
    #select the number of clusters with the best separation among clusters.
    k = as.numeric(names(mean.cl.width)[which.max(mean.cl.width)])

    #cluster the rows of the value matrix
    gene.clust <- hclust(dist(value.mat))

    #cut the dendrogram based on the best number of clusters selected above.
    gene.groups <- cutree(gene.clust, k = k)

    group.vals <- lapply(1:k, function(x) value.mat[names(which(gene.groups == x)),,drop=FALSE]) 

    #look for functional enrichment of the gene clusters
    group.gene.names <- lapply(1:k, 
        function(x) names(gene.groups)[which(gene.groups == x)])
    group.enrich <- lapply(group.gene.names, 
        function(x) gost(x, organism = "mmusculus", 
        source = c("GO", "REACTOME", "KEGG", "WP", "CORUM", "HP")))
        
    #select the term with the smallest p value to represent 
    #each group
    group.labels <- sapply(group.enrich, get_max_enrich)
    names(group.enrich) <- names(group.gene.names) <- group.labels

    results <- list("group_enrich" = group.enrich, "group_genes" = group.gene.names, 
        "loadings" = value.mat, "grouped_values" = group.vals)
    invisible(results)

}

plot_clustered_values <- function(cluster_results){

    group.enrich <- cluster_results$group_enrich
    value.mat <- cluster_results$loadings
    group.gene.names <- cluster_results$group_genes
    group.labels <- names(group.enrich)
    group.vals <- cluster_results$grouped_values

    enrich.labels <- lapply(1:length(group.enrich), 
        function(x) rep(group.labels[x], length(group.gene.names[[x]])))

    #create a data frame so we can annotate the groups in pheatmap
    enrich.df <- data.frame(as.factor(unlist(enrich.labels)))
    rownames(enrich.df) <- unlist(group.gene.names)
    colnames(enrich.df) <- "Enrichment"
    class_cols <- c(brewer.pal(12, "Paired"), brewer.pal(12, "Set3"))
    
    u_groups <- unique(unlist(enrich.labels))
    names(u_groups) <- paste("Group", 1:length(u_groups))

    ann_cols <- list("Enrichment" = class_cols[1:length(u_groups)])
    names(ann_cols[[1]]) <- u_groups
    #par(mar = c(12, 4, 4, 4));barplot(rep(1, length(group.labels)), col = class_cols[1:length(group.labels)], names = group.labels, las = 2)

    pheatmap(value.mat, annotation_row = enrich.df, 
        show_rownames = FALSE, cluster_cols = FALSE, annotation_colors = ann_cols)

    #further descriptions of enrichments for groups
    par(mfrow = c(3,1), mar = c(2,4,2,4))
    group.labels <- levels(enrich.df[,1])
    for(g in 1:length(group.enrich)){
        group.enrich.name = get_max_enrich(group.enrich[[g]])
        group.col <- ann_cols[[1]][which(names(ann_cols[[1]]) == group.enrich.name)]
        plot.enrichment(group.enrich[[g]], 
            plot.label = paste("Group:", group.enrich.name),
            num.terms = 20, title.color = group.col, order.by = "p_value")
    }

    #show value distributions per group
    par(mfrow = c(3,2), mar = c(4,4,4,4))
    for(g in 1:length(group.vals)){
        boxplot(group.vals[[g]], main = get_max_enrich(group.enrich[[g]]))
        abline(h = 0)
    }
}
```

There are lots of very strong loadings among the transcripts. 
These are transcripts that are highly related to the traits,
but do not necessarily have local eQTL in the population.

Transcripts without local eQTL are those that are highly
constrained in this population and not allowed to vary 
based on genetics. But they can still have a large effect
on the trait when they do vary. We would expect genes in this
list to have a large impact if manipulated artificially, say
with a KO.

The loading patterns are quite tissue-specific. Clusters
of genes tend to be active in individual tissues. There are some
shared clusters:
    Adipose and liver share negative loadings in the macromolecule
        biosynthesis cluster
    Adipose and skeletal muscle share positive loadings in the 
        transmembrane activity cluster

```{r toa_load, warning = FALSE, message = FALSE}

transcript.loading.list <- lapply(transcript_loadings, function(x) x[,1])

toa_loadings_file <- file.path(results.dir, paste0("TOA_Transcript_Loadings_", adjust_numeral, "_Results.RDS"))
if(!file.exists(toa_loadings_file)){
   toa.results <- cluster_values(value.list = transcript.loading.list, z.thresh = 3, 
        k.seq = 3:20)
    saveRDS(toa.results, toa_loadings_file)
}else{
    toa.results <- readRDS(toa_loadings_file)
}

graphics.off()
pdf(file.path(results.dir, paste0("TOA_Transcript_Loadings_", adjust_numeral, ".pdf")))
plot_clustered_values(toa.results)
dev.off()

#write out gene lists for each cluster
gene.lists <- toa.results[[2]]
for(g in 1:length(gene.lists)){
    file.name <- paste0(gsub(" ", "_", names(gene.lists)[g]), "_cluster.txt")
    write.table(gene.lists[[g]], here("Results", "DO", "Gene_Sets", file.name),
        sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)
}

```

# Extra

### Loadings vs. LOD {.tabset .tabset-fade .tabset-pills}

I don't think this is relevant anymore, but I don't want to
take the code out completely.

Another way to look at the relationship between transcript
loading and local variance explained is to use LOD score
as a measure of the variance explained. Geneticists are 
also used to looking at eQTL LOD scores.

What is the maximum eQTL LOD score for transcripts compared with 
their loading? The following plots show the loading of each 
transript vs. its maximum LOD score. We see a negative
relationship between loading and LOD score.

```{r to_label}
num.label = 30 #the number of top genes to label in the plots below
```

The `r num.label` genes along the edge are labeled.

The plots are saved as pdfs called LOD_vs_Loading_tissue_name
so that the gene names are searchable and highlightable.

```{r lod_v_loading, fig.width = 8, fig.height = 6, results = "asis"}
convex.layers <- 3

if(mediation.text == "complete_mediation"){
    for(tx in 1:length(tissue.names)){
        cat("####", tissue.names[tx], "\n")

        eqtl.table <- tissue.lod[[tx]]

        gene.id <- rownames(transcript_loadings[[tx]])
        gene.name <- gene.tables[[tx]]$symbol[match(gene.id, gene.tables[[tx]]$gene.id)]
        gene.lod <- lapply(gene.id, function(x) eqtl.table$lod[which(eqtl.table$gene.id == x)])
        max.lod <- sapply(gene.lod, function(x) if(length(x) > 0){max(x)}else{3})
        xmax <- max(max.lod)*1.1
                
        #pdf(file.path(results.dir, paste0("LOD_vs_Loading_", tissue.names[tx], "_", adjust_numeral, ".pdf")), width = 10, height = 8)
        layout(matrix(c(1,1,2,3), ncol = 2, byrow = FALSE), widths = c(1, 0.5))
        par(mar = c(4,4,4,0))

        convex.idx <- vector(mode = "list", length = convex.layers)
        lod.idx <- loading.idx <- 1:length(max.lod)        
        x <- max.lod[lod.idx]
        y <- transcript_loadings[[tx]][lod.idx,]
        for(cv in 1:convex.layers){
            hull <- convex.hull(cbind(x,y))
            convex.idx[[cv]] <- names(y)[hull[[1]]]
            x <- x[-hull[[1]]]
            y <- y[-hull[[1]]]
        }
        hull.idx <- match(unlist(convex.idx), rownames(transcript_loadings[[tx]]))
        #don't label anything with a local LOD score < 25
        high.lod <- which(max.lod > 25)
        hull.idx <- intersect(hull.idx, high.lod)
        plot(max.lod, transcript_loadings[[tx]], xlab = "Maximum LOD", ylab = "Loading", 
            main = tissue.names[tx], pch = 16, cex = 0.5, xlim = c(0, xmax))
        points(max.lod[hull.idx], transcript_loadings[[tx]][hull.idx,1], col = "red")
        text(max.lod[hull.idx], transcript_loadings[[tx]][hull.idx,1], 
            labels = gene.name[hull.idx], pos = 4, cex = 0.7)
        abline(h = 0)  
        
        pos.hull.idx <- intersect(hull.idx, which(transcript_loadings[[tx]][,1] > 0))
        top.genes <- gene.name[pos.hull.idx]
        ordered.top <- top.genes[order(max.lod[pos.hull.idx], decreasing = TRUE)]
        pos.par <- words_to_paragraph(ordered.top, line.len = 5)
        par(mar = c(0,0,0,0))
        plot.text(paste("Positive Loading Genes", pos.par, sep = "\n\n"))
        
        neg.hull.idx <- intersect(hull.idx, which(transcript_loadings[[tx]][,1] < 0))
        bottom.genes <- gene.name[neg.hull.idx]
        ordered.bottom <- bottom.genes[order(max.lod[neg.hull.idx], decreasing = TRUE)]
        neg.par <- words_to_paragraph(ordered.bottom, line.len = 5)
        par(mar = c(0,0,0,0))
        plot.text(paste("Negative Loading Genes", neg.par, sep = "\n\n"))
        #dev.off()
        cat("\n\n")
    }
}

```