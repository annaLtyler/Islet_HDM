---
title: "Cell Type Validation"
author: Anna L Tyler
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: hide
    collapsed: no
    toc: yes
    toc_float: yes
---

## Introduction

The purpose of this workflow is to look at markers of 
specific cell types in the adipose tissue to see if we
can see elevated levels of specific cell types in different
subsets of mice. 

We downloaded two data sets with cell-type-specific 
gene lists, one for adipose tissue, and one for 
pancreatic islets. 

* Adipose tissue:
    * [Ehrlund et al. 2017](https://pubmed.ncbi.nlm.nih.gov/29087381/) 
    published a set of markers specific
    to different cell types in human adipose tissue. We can
    use these markers to look for cell composition variation
    in the DO mice.

* Pancreatic islets:
    * [Elgamal et al. 2023](https://pubmed.ncbi.nlm.nih.gov/36778506/) 
    used single-cell RNA Seq to identify
    cell-type specific transcripts in pancreatic tissue donated
    by patients with type 1 and type 2 diabetes as part of the 
    Human Pancreas Analysis Program. They provide a list of the
    top ten cell-type-specific genes for each of 

```{r load_code}
rm(list = ls())

#is.interactive = TRUE
library("here")

exp.name = "tissue_together-_-complete_mediation-germline_kinship"

prev.results.dir <- here("Results", "DO", "High_Dim_Med_no_MGE", exp.name)

all.fun <- list.files(here("Code"), full.names = TRUE, pattern = ".R")
for(i in 1:length(all.fun)){source(all.fun[i])}

```

```{r load_libraries, message = FALSE, warning = FALSE, error = FALSE}
all.packages <- c("pheatmap", "gprofiler2", "RColorBrewer", "GEOquery", "limma", 
    "vioplot", "pdftools")

all.paths <- .libPaths()
personal.path <- grep("atyler", all.paths)
load_libraries(all.packages, lib.loc = all.paths[personal.path])
```

## Adipose Tissue

Ehrlund et al. PMID: 29087381

```{r read_adipose_data}

model_scores <- readRDS(file.path(prev.results.dir, "Model_Scores_0.RDS"))

transcript_loadings <- readRDS(file.path(prev.results.dir, "Loadings_Transcripts_0.RDS"))
tissue.names <- names(transcript_loadings)

#tissue.cols <- c("orange", "#8dd3c7", "tan", "brown") #colors that are not related to the DO/CC colors
#tissue.cols  <- colors.from.values(1:length(tissue.names), split.at.vals = TRUE, #nicer colors
#    split.points = seq(0.5, 4.5, 1), 
#    col.scale = c("blue", "red", "green", "purple"), light.dark = "d")
tissue.cols <- as.matrix(read.delim(here("Data", "general", "tissue_colors.txt"), header = FALSE, row.names = 1))[,1]
#barplot(rep(1, length(tissue.cols)), col = tissue.cols, names = names(tissue.cols))

adj.expr <- readRDS(here("Results", "DO", "Data", "Tissue_Expression_Adjusted.RDS")) #generated by 1a.Tissue_Expression.Rmd

mus.hum <- read.delim(here("Data", "general", "human.mouse.orthologs.txt"))

#cell_type_data
cell_type_row <- read.delim(here("Data", "Human", "Ehrlund_et_al", "Selected_enriched_genes_all_fractions.txt"),
    skip = 2, nrows = 1, strip.white = TRUE, header = FALSE)
cell_types <- cell_type_row[which(!is.na(cell_type_row))]
cell_type_col <- lapply(cell_types, function(x) c(which(cell_type_row == x), which(cell_type_row == x)+1))
names(cell_type_col) <- cell_types

cell_type_table <- read.delim(here("Data", "Human", "Ehrlund_et_al", "Selected_enriched_genes_all_fractions.txt"),
    skip = 3, strip.white = TRUE)
cell_tables <- lapply(cell_type_col, function(x) cell_type_table[,x])

matched_cell_tables <- vector(mode = "list", length = length(cell_tables))
names(matched_cell_tables) <- cell_types
#find orthologs of cell type data
for(ct in 1:length(cell_tables)){
    hum.gene.name <- cell_tables[[ct]][,1]
    common.name <- intersect(hum.gene.name, mus.hum[,"Human.Gene.Name"])
    matched.table <- mus.hum[match(common.name, mus.hum[,"Human.Gene.Name"]),]
    matched_cell_tables[[ct]] <- matched.table
}
```

The plot below shows the relative distribution of loadings across
cell types. Negative loadings mean that higher proportions of these
cells are associated with less obesity and insulin resistance.

Positive loadings mean that higher proportions of these
cells are associated with greater obesity and insulin 
resistance.

So for example, if the tissue is mostly adipose cells, as opposed
to some adipose cells and lots of macrophages, that indicates
a healthier animal. Tissue that has a higher abundance of macrophages
is likely to be from an obese animal with higher insulin resistance.

Progenitor cells don't seem to be different in obese and lean animals.
This is not really what they saw in Ehrlund et al. They saw that obese
people had slightly fewer progenitor cells, and more macrophages.

```{r loadings, fig.height = 5, fig.width = 5}

adipose.loadings <- transcript_loadings$Adipose

matched.genes <- lapply(matched_cell_tables, function(x) intersect(x[,"Mouse.Ortholog.Ensembl"], rownames(adipose.loadings)))
adipose_type_loadings <- lapply(matched.genes, function(x) adipose.loadings[x,])

all.load <- unlist(adipose_type_loadings)
fact <- as.factor(unlist(lapply(names(adipose_type_loadings), function(x) rep(x, length(adipose_type_loadings[[x]])))))
#vioplot(all.load~fact, xlab = "Cell Type", ylab = "Loading", col = "lightgray")

adipose.order <- order(sapply(adipose_type_loadings, mean))
par(mar = c(8,4,4,4))
boxplot(adipose_type_loadings[adipose.order], xlab = "", ylab = "Loading", col = "lightgray", las = 2)
stripchart(adipose_type_loadings[adipose.order],
    vertical = TRUE, add = TRUE, pch = 16, 
    col = tissue.cols[1], method = "jitter")
abline(h = 0)
```

Originally, I looked at how well these gene subsets did 
at predicting phenotype when loaded up with our loadings.
It looked as if they did well, but it turns out that any
set of randomly selected genes does very well when 
multiplied by the loadings, so this analysis is meaningless.
I have deleted the code that did the predictions for cell
types.

## Pancreatic Islets

Elgamal et al. PMID: 36778506

I downloaded the supplementary tables from [Figshare](https://diabetesjournals.figshare.com/articles/figure/_b_An_integrated_map_of_cell_type-specific_gene_expression_in_pancreatic_islets_b_/23925765)
The tables are stored in a pdf, so we use pdftools to
parse them. We use the following tables provided by the
authors:

* Supplementary table 3: Established cell-type-specific 
    genes.

* Supplementary table 4: top ten marker genes for
    cell types.

* Supplementary table 5: top ten marker genes for 
    cellular subtypes.

```{r table_fun}
#each table has a different format, so we will make a
#different function to parse each.
parse_prev_genes <- function(unparsed_row){
    split_row <- strsplit(unparsed_row, " ")[[1]]
    info_idx <- which(split_row != "")
    gene_name <- split_row[info_idx[1]] #always first
    gene_id <- split_row[info_idx[2]] #always second

    #there are always multiple spaces between the full 
    #gene name and the cell typem but both vary in the 
    #number of words they have. Find the gap with multiple
    #spaces. Use everything before the gap as the full
    #gene name, and everything after as the cell type

    final_info <- info_idx[3:length(info_idx)]
    consec_info <- consec_pairs(final_info)
    num_spaces <- consec_info[,2] - consec_info[,1]
    gap_idx <- which(num_spaces > 1)

    #if there is no gap just return as is
    if(length(gap_idx) == 0){ 
        return(unparsed_row)
    }

    #if there is more than one gap, this is the header row. 
    #return the final headers
    if(length(gap_idx) > 1){
        parsed_row <- c("Gene_Name", "Gene_ID", "Full_Name", "Cell_Type")
    }

    if(length(gap_idx) == 1){
        full_name <- paste(split_row[final_info[1:(gap_idx)]], collapse = " ")
        cell_type <- paste(split_row[final_info[c((gap_idx+1):length(final_info))]], collapse = " ")
        parsed_row <- c("gene_name" = gene_name, "gene_id" = gene_id, "full_name" = full_name, 
            "cell_type" = cell_type)
    }

    return(parsed_row)
}

parse_top_ten <- function(unparsed_row){
    split_row <- strsplit(unparsed_row, " ")[[1]]
    info_idx <- which(split_row != "")

    if(split_row[1] == "Cell"){
        parsed_row <- c("Cell_Type", "Gene")
    }else{
        cell_type <- split_row[info_idx[1]]
        gene_name <- split_row[info_idx[2]] 
        parsed_row = c("Cell_Type" = cell_type, "Gene" = gene_name)
    }
    return(parsed_row)
}

parse_top_ten_subtype <- function(unparsed_row){
    split_row <- strsplit(unparsed_row, " ")[[1]]
    info_idx <- which(split_row != "")

    if(split_row[1] == "Cell"){
        parsed_row <- c("Cell_Type", "Gene")
    }else{
        cell_type <- paste(split_row[info_idx[1:2]], collapse = " ")
        gene_name <- split_row[info_idx[3]] 
        parsed_row = c("Cell_Type" = cell_type, "Gene" = gene_name)
    }
    return(parsed_row)
}
```

```{r read_islet_data}
supp_tables <- here("Data", "Human", "Elgamal_et_al", 
    "DB23-0130 Online_Supplemental_Materials_Tables_Revised.KJG.pdf")
all_tables <- pdf_text(supp_tables)
parsed_tables <- strsplit(all_tables, "\n")

prev.genes <- parsed_tables[[4]]
prev.gene.table <- t(sapply(prev.genes[3:length(prev.genes)], parse_prev_genes))
colnames(prev.gene.table) <- parse_prev_genes(prev.genes[2])

top_ten <- parsed_tables[[5]]
top_ten_table1 <- Reduce("rbind", lapply(top_ten[3:length(top_ten)], parse_top_ten))
top_ten_table2 <- Reduce("rbind", lapply(parsed_tables[[6]], parse_top_ten))
top_ten_table <- rbind(top_ten_table1, top_ten_table2)
colnames(top_ten_table) <- c("Cell_Type", "Gene_Name")
rownames(top_ten_table) <- NULL


top_ten_subtype <- parsed_tables[[7]]
top_ten_subtype_table <- Reduce("rbind", lapply(top_ten_subtype[3:length(top_ten_subtype)], parse_top_ten_subtype))

merged_table <- rbind(cbind(as.vector(prev.gene.table[,4]), as.vector(prev.gene.table[,1])),
    top_ten_table, top_ten_subtype_table)

u_cells <- unique(top_ten_table[,1])
```

Translate these genes to the mouse orthologs and find the loadings.

```{r orthologs, fig.width = 7, fig.height = 5}
mouse.gene.table <- t(sapply(merged_table[,2], 
    function(x) mus.hum[match(x, mus.hum[,"Human.Gene.Name"]),c("Mouse.Ortholog.Name", 
    "Mouse.Ortholog.Ensembl")]))

full_info_table <- cbind(merged_table, mouse.gene.table)
rownames(full_info_table) <- NULL

all_cells <- unlist(top_ten_table[,1])
u_cells <- unique(all_cells)

islet_loadings <- transcript_loadings$Islet

islet_cell_loadings <- vector(mode = "list", length = length(u_cells))
names(islet_cell_loadings) <- u_cells
for(ct in 1:length(u_cells)){
    cell.idx <- which(all_cells == u_cells[ct])
    cell.genes <- unlist(full_info_table[,4])[cell.idx]
    gene.idx <- match(cell.genes, rownames(islet_loadings))
    islet_cell_loadings[[ct]] <- islet_loadings[gene.idx,1]
}

cell.mean <- sapply(islet_cell_loadings, function(x) mean(x, na.rm = TRUE))
islet.order <- order(cell.mean)
par(mar = c(8,4,4,4))
boxplot(islet_cell_loadings[islet.order], las = 2)
abline(h = 0)
stripchart(islet_cell_loadings[islet.order], add = TRUE, pch = 16, 
    col = tissue.cols[2], method = "jitter", vertical = TRUE)
```

Genes associated with Gamma+Epsilon, Endothelial, and Delta cells all 
had negative loadings on average. Alpha cells tend to have positive 
loadings. This suggests that mice with proprotionally fewer of the 
first set of cells and more alpha cells are at risk for obesity.
Does this make sense?


The following plots are for figures either showing all
data on the same axes in separate plots or showing all
data on a single plot.

```{r single_plot}
all.types <- c(adipose_type_loadings, islet_cell_loadings)
all.min <- min(sapply(all.types, function(x) min(x, na.rm = TRUE)))
all.max <- max(sapply(all.types, function(x) max(x, na.rm = TRUE)))

#pdf("~/Desktop/adipose_type_loadings.pdf", width = 5, height = 5)
par(mar = c(11,7,2,2))
boxplot(adipose_type_loadings[adipose.order], las = 2, ylim = c(all.min, all.max),
    cex.axis = 1.5, col = tissue.cols[1])
#xjitter <- lapply(1:length(adipose_type_loadings), function(x) jitter(rep(x, length(adipose_type_loadings[[x]])), factor = 2))
#a <- lapply(1:length(adipose_type_loadings), function(x) points(xjitter[[x]], adipose_type_loadings[[adipose.order[x]]], pch = 16, col = tissue.cols[1]))
#a <- lapply(1:length(adipose_type_loadings), function(x) points(xjitter[[x]], adipose_type_loadings[[adipose.order[x]]], pch = 21, col = "gray20"))
stripchart(adipose_type_loadings[adipose.order],
    vertical = TRUE, add = TRUE, pch = 16,
    col = "darkgray", method = "jitter")
mtext("Loading", side = 2, line = 4.5, cex = 1.5)
abline(h = 0)
#dev.off()

#pdf("~/Desktop/islet_type_loadings.pdf", width = 8, height = 5)
par(mar = c(11,7,2,2))
boxplot(islet_cell_loadings[islet.order], las = 2, ylim = c(all.min, all.max),
    cex.axis = 1.5, col = tissue.cols[2])
#xjitter <- lapply(1:length(islet_cell_loadings), function(x) jitter(rep(x, length(islet_cell_loadings[[x]])), factor = 2))
#a <- lapply(1:length(islet_cell_loadings), function(x) points(xjitter[[x]], islet_cell_loadings[[islet.order[x]]], pch = 16, col = tissue.cols[2]))
#a <- lapply(1:length(islet_cell_loadings), function(x) points(xjitter[[x]], islet_cell_loadings[[islet.order[x]]], pch = 21, col = "gray20"))
stripchart(islet_cell_loadings[islet.order],
    vertical = TRUE, add = TRUE, pch = 16,
    col = "gray30", method = "jitter")
mtext("Loading", side = 2, line = 4.5, cex = 1.5)
abline(h = 0)
#dev.off()

type.cols <- c(rep(tissue.cols[1], length(adipose_type_loadings)), rep(tissue.cols[2], length(islet_cell_loadings)))
all.order <- order(sapply(all.types,  function(x) mean(x, na.rm = TRUE)))
boxplot(all.types[all.order], las = 2)
stripchart(all.types[all.order],
    vertical = TRUE, add = TRUE, pch = 16, 
    col = type.cols[all.order], method = "jitter")
abline(h = 0)

```

## Differentially Expressed Genes

Elgamal et al. also provide a table of genes that 
are differentially expressed in T1D patients compared
to controls. Some of these genes are lower in T1D and
some are higher. This means we should pay attention to
the sign for these ones, so we will weight our loadings
by the beta coefficient for the gene.


```{r diff_exp, fig.width = 7, fig.height = 5}
parse_diff_expr <- function(unparsed_row){
    split_row <- strsplit(unparsed_row, " ")[[1]]
    info_idx <- which(split_row != "")
    #split_row[info_idx]

    if(info_idx[2] == 2){ #the cell name has two words
        cell_type <- paste(split_row[1:2], collapse = " ")
        gene_name <- split_row[3]
        stat <- split_row[info_idx[7]]
    }else{ #the cell name has one word
        cell_type <- split_row[1]
        gene_name <- split_row[info_idx[2]]
        stat <- split_row[info_idx[6]]
    }

    #exception
    if(split_row[1] == "Gamma+Epsilon"){
        cell_type <- split_row[1]
        gene_name <- split_row[info_idx[2]]
        stat <- split_row[info_idx[6]]
    }

    parsed_row = c("Cell_Type" = cell_type, "Gene" = gene_name, "Stat" = stat)

    return(parsed_row)
}

diff_expr1 <- parsed_tables[[8]]
#diff_expr1 <- parsed_tables[[32]]
#unparsed_row <- diff_expr1[51]
diff_expr_genes <- Reduce("rbind", lapply(diff_expr1[3:length(diff_expr1)], parse_diff_expr))
diff_expr_other <- Reduce("rbind", lapply(parsed_tables[9:32], function(x) Reduce("rbind", lapply(x, parse_diff_expr))))
#there is some weird formatting for the last two rows, but it's only
#two genes, so we can ignore these
diff_expr_full <- rbind(diff_expr_genes, diff_expr_other[1:(nrow(diff_expr_other)-4),]) 

mouse.gene.table <- t(sapply(diff_expr_full[,2], 
    function(x) mus.hum[match(x, mus.hum[,"Human.Gene.Name"]),c("Mouse.Ortholog.Name", 
    "Mouse.Ortholog.Ensembl")]))

diff_expr_info <- cbind(diff_expr_full, mouse.gene.table)

all_cells <- unlist(diff_expr_info[,1])
u_cells <- unique(all_cells)

weighted_islet_loadings <- vector(mode = "list", length = length(u_cells))
names(weighted_islet_loadings) <- u_cells
for(ct in 1:length(u_cells)){
    cell.idx <- which(all_cells == u_cells[ct])
    cell.genes <- unlist(diff_expr_info[,5])[cell.idx]
    gene.idx <- match(cell.genes, rownames(islet_loadings))
    weighted.loadings <- islet_loadings[gene.idx,1]*as.numeric(diff_expr_info[cell.idx,3])
    weighted_islet_loadings[[ct]] <- weighted.loadings
}

cell.mean <- sapply(weighted_islet_loadings, function(x) median(x, na.rm = TRUE))
par(mar = c(8,4,4,4))
boxplot(weighted_islet_loadings[order(cell.mean)], las = 2)
abline(h = 0)
stripchart(weighted_islet_loadings[order(cell.mean)], add = TRUE, pch = 16, 
    col = "#1f78b4", vertical = TRUE)

```

## Random Gene Check

The code below shows that any randomly selected set of 
genes can predict phenotype score in the mice.

```{r perm_pred}
#creates a prediction based on a random sample of 
#genes and calculates the correlation between the
#phenotype score and the predicted phenotype
#score generated by the random genes.

perm_pred <- function(expr.mat, tx.loadings, pheno.score, n.genes){

    cell.genes <- sample(rownames(tx.loadings), n.genes)
    ct_genes <- intersect(cell.genes, colnames(expr.mat))
    ct_expr <- expr.mat[,ct_genes]
    loaded_expr <- apply(ct_expr, 1, function(x) x*tx.loadings[ct_genes,])
    pred_expr <- colMeans(loaded_expr)
    common.ind <- intersect(names(pred_expr), names(pheno.score))
    result <- plot.with.model(pred_expr[common.ind], pheno.score[common.ind], 
        plot.results = FALSE)
    r2 <- result[[1]]
    return(r2)
}

```

```{r random_check, fig.width = 8, fig.height = 4}

adipose.expr <- adj.expr$Adipose
scaled.expr <- apply(adipose.expr, 2, scale)
rownames(scaled.expr) <- rownames(adipose.expr)

n_perm = 100
n_genes <- c(10, 20, 50)
null_dist <- vector(mode = "list", length = length(n_genes))
perm.dir <- here("Results", "Human_Validation", "Cell_Types")
if(!file.exists(perm.dir)){dir.create(perm.dir, recursive = TRUE)}

for(p in 1:length(n_genes)){
    perm.file <- file.path(perm.dir, paste0("pred_perm_", n_genes[p], ".RDS"))
    if(!file.exists(perm.file)){
        null_dist[[p]] <- sapply(1:n_perm, function(x) perm_pred(scaled.expr, transcript_loadings$Adipose,
            model_scores$Adipose[,"Outcome"], n_genes[p]))
        saveRDS(null_dist[[p]], perm.file)
    }else{
        null_dist[[p]] <- readRDS(perm.file)
    }
}

a <- lapply(null_dist, function(x) hist(x, plot = FALSE))
max.dens <- max(sapply(a, function(x) max(x$density)))
plot.new()
plot.window(xlim = c(0,1), ylim = c(0, max.dens))
for(p in 1:length(null_dist)){
    points(density(null_dist[[p]]), col = p, type = "l", lwd = 2)
}
axis(1)
axis(2)
legend("topleft", lwd = 2, col = 1:length(null_dist), legend = n_genes, title = "# genes")
mtext("Null Distributions for Prediction R2")
```

The following code looks at the likelihood that any randomly 
selected set of genes will have a mean loading different from
zero. It places the mean loadings for each of our cell types
on the plot. 

We do this separately for each cell type. The fewer genes there
are in a set, the more likely it is that the mean of the 
loadings will be non-zero just by chance. We therefore want
to compare the mean loading of each gene set to a random
draw of the same size. The islet cell types all have the
same number of genes: 10, so we only need to do one set 
of permutations for each of these.

The figure below shows the null distribution loading means
for 10k random draws of the appropriate loading distribution
using the number of genes in the cell-type-specific subset.

The red starts indicate the mean loading of the actual genes
in the cell-type-specific subset. The small horizontal black
lines show p value cutoff of 0.001

```{r loading_p, fig.height = 6, fig.width = 10}
alpha = 0.01
num_perm = 10000

#find the mean loading for each cell type in each tissue
mean_adipose_loadings <- sapply(adipose_type_loadings, function(x) mean(x, na.rm = TRUE))
mean_islet_loadings <- sapply(islet_cell_loadings, function(x) mean(x, na.rm = TRUE))

adipose.mean.mat <- matrix(NA, ncol = length(adipose_type_loadings), nrow = num_perm)
colnames(adipose.mean.mat) <- names(adipose_type_loadings)
adipose.alpha.mat <- matrix(NA, nrow = length(adipose_type_loadings), ncol = 2)
rownames(adipose.alpha.mat) <- names(adipose_type_loadings)
colnames(adipose.alpha.mat) <- c("upper_thresh", "lower_thresh")
for(ct in 1:length(adipose_type_loadings)){
    sampled_loading <- lapply(1:num_perm, 
        function(x) sample(transcript_loadings$Adipose, length(adipose_type_loadings[[ct]])))
    sampled.means <- sapply(sampled_loading, mean)
    adipose.mean.mat[,ct] <- sampled.means
    adipose.alpha.mat[ct,1] <- get.percentile(sampled.means, (1-alpha)*100)
    adipose.alpha.mat[ct,2] <- get.percentile(sampled.means, alpha*100)
}

islet.mean.mat <- matrix(NA, ncol = length(islet_cell_loadings), nrow = num_perm)
colnames(islet.mean.mat) <- names(islet_cell_loadings)
islet.alpha.mat <- matrix(NA, nrow = length(islet_cell_loadings), ncol = 2)
rownames(islet.alpha.mat) <- names(islet_cell_loadings)
colnames(islet.alpha.mat) <- c("upper_thresh", "lower_thresh")
for(ct in 1:length(islet_cell_loadings)){
    sampled_loading <- lapply(1:num_perm, 
        function(x) sample(transcript_loadings$Islet, length(islet_cell_loadings[[ct]])))
    sampled.means <- sapply(sampled_loading, function(x) mean(x, na.rm = TRUE))
    islet.mean.mat[,ct] <- sampled.means
    islet.alpha.mat[ct,1] <- get.percentile(sampled.means, (1-alpha)*100)
    islet.alpha.mat[ct,2] <- get.percentile(sampled.means, alpha*100)
}

all_samples <- cbind(adipose.mean.mat, islet.mean.mat)
all_alpha <- rbind(adipose.alpha.mat, islet.alpha.mat)
xmin <- min(c(all_alpha, mean_adipose_loadings, mean_islet_loadings))*1.05
xmax <- max(c(all_alpha, mean_adipose_loadings, mean_islet_loadings))*1.05

plot.cols <- c(rep(tissue.cols[1], length(adipose_type_loadings)), 
    rep(tissue.cols[2], length(islet_cell_loadings)))

asterisk.col <- "red"
par(mar = c(11,8,2,4))
vioplot(all_samples, col = plot.cols, ylim = c(xmin, xmax), axes = FALSE,
    main = "Null Loading Distribution", las = 2, cex.axis = 1.5)
mtext("Loading", side = 2, line = 5, cex = 1.5)
#add the mean loading value for each adipose cell type along with alpha 
#cutoff lines
for(i in 1:length(mean_adipose_loadings)){
    points(x = i, y = mean_adipose_loadings[i], pch = "*", col = asterisk.col, cex = 3)
    segments(x0 = i-0.25, x1 = i+0.25, y0 = adipose.alpha.mat[i,])
}

#add the mean loading value for each islet cell type along with alpha 
#cutoff lines
for(i in 1:length(mean_islet_loadings)){
    xval <- i+length(mean_adipose_loadings)
    points(x = xval, y = mean_islet_loadings[i], pch = "*", col = asterisk.col, cex = 3)
    segments(x0 = xval-0.25, x1 = xval+0.25, y0 = islet.alpha.mat[i,])
}

```

## Subsets

We can derive scores for each animal based on their expression of 
the cell-type-specific genes. We can then look for subsets of 
animals that are maybe at risk for inflammation in the adipose,
but not for reduced endothelial cells in the islet, for example.

```{r subsets, fig.width = 9, fig.height = 4}

combined_loadings <- list("Adipose_Macrophages" = adipose_type_loadings$Macrophages, 
    "Adipose_Adipocytes" = adipose_type_loadings$Adipocytes,
    "Islet_Alpha" = islet_cell_loadings$Alpha, 
    "Islet_Endothelial" = islet_cell_loadings$Endothelial,
    "Islet_Delta" = islet_cell_loadings$Delta,
    "Islet_Beta" = islet_cell_loadings$Beta)

common.ind <- intersect(rownames(model_scores$Adipose), rownames(model_scores$Islet))
scaled.expr <- lapply(adj.expr[1:2], function(x) apply(x[common.ind,], 2, scale))
for(i in 1:length(scaled.expr)){
    rownames(scaled.expr[[i]]) <- common.ind
}

#generate scores for each individual based on each cell type
cell_type_scores <- matrix(NA, ncol = length(common.ind), nrow = length(combined_loadings))
rownames(cell_type_scores) <- names(combined_loadings)
colnames(cell_type_scores) <- common.ind
for(ct in 1:length(combined_loadings)){
    tissue.name <- strsplit(names(combined_loadings)[ct], "_")[[1]][1]
    tissue.idx <- which(names(scaled.expr) == tissue.name)
    common.tx <- intersect(colnames(scaled.expr[[tissue.idx]]), names(combined_loadings[[ct]]))
    #loaded_expr <- apply(scaled.expr[[tissue.idx]][,common.tx], 1, function(x) x*combined_loadings[[ct]][common.tx])
    #abs loadings
    loaded_expr <- apply(scaled.expr[[tissue.idx]][,common.tx], 1, function(x) x*abs(combined_loadings[[ct]][common.tx]))
    cell_type_scores[ct,] <- colMeans(loaded_expr)
}

pheno.score <- model_scores[[1]][common.ind,"Outcome"]
df <- data.frame("Phenotype_Score" = pheno.score)
phenotype.order <- reorder_dendrogram(t(cell_type_scores), pheno.score)
#phenotype.order <- order(pheno.score)
pheatmap(cell_type_scores[,phenotype.order], cluster_cols = FALSE, 
    show_colnames = FALSE, scale = "row", annotation_col = df)

#pheno_tree <- hclust(dist(t(cell_type_scores)))
#plot(pheno_tree)

```

Another way to look at it is the following

```{r, points, fig.height = 7, fig.width = 7}
phenotype.order <- order(pheno.score)
layout.mat <- matrix(c(1:(nrow(cell_type_scores)+1)), ncol = 1)

layout(layout.mat)
par(mar = c(1,4,2,14))
plot(pheno.score[phenotype.order], type = "p", axes = FALSE, xlab = "", ylab = "")
plot.dim <- par("usr")
draw.rectangle(plot.dim[1], plot.dim[2], plot.dim[3], plot.dim[4],
    border = "lightgray")

abline(h = 0)
mtext("Phenotype", side = 4, las = 2)
par(mar = c(1,4,0,14))
for(i in 1:nrow(cell_type_scores)){
    plot(cell_type_scores[i,phenotype.order], type = "p", axes = FALSE, xlab = "",
        ylab = "")
    plot.dim <- par("usr")
    draw.rectangle(plot.dim[1], plot.dim[2], plot.dim[3], plot.dim[4],
        border = "lightgray")
    model <- loess(cell_type_scores[i,phenotype.order]~c(1:length(phenotype.order)))
    pred.model <- predict(model)
    points(pred.model, col = "#1f78b4", type = "l", lwd = 4)
    abline(h = 0)
    mtext(rownames(cell_type_scores)[i], side = 4, las = 2)
}

```

The cell type profiles are all pretty highly correlated
with each other. Adipose macrophage and islet ductal 
cell profiles are particularly highly correlated with
each other.

```{r cell_type_cor, fig.width = 5, fig.height = 5}
pheatmap(cor(t(cell_type_scores)), display_numbers = TRUE)
```


```{r cell_cor_points, fig.width = 9, fig.height = 6}
pheno.col <- colors.from.values(pheno.score, use.pheatmap.colors = TRUE)

par(mfrow = c(2,3))
pheno.order <- order(pheno.score, decreasing = FALSE)

for(i in 1:nrow(cell_type_scores)){    
    model <- loess(cell_type_scores[i,pheno.order]~pheno.score[pheno.order])
    pred.line <- predict(model)
    plot(pheno.score, cell_type_scores[i,],
        ylab = rownames(cell_type_scores)[i], 
        xlab = "Phenotype Score")
    points(pheno.score[pheno.order], pred.line, col = "lightblue", type = "l", lwd = 3)
}
```

```{r set_k}
k = 3
```

The individuals do cluster based on their correlation.
We can cluster this correlation matrix into multiple groups
and look for phenotypic differences as well as cell type differences.
Here we look at `r k` groups.

```{r cluster_cor, fig.width = 7, fig.height = 5}
ind.cor <- cov(cell_type_scores)
ind_tree <- hclust(dist(ind.cor))
groups <- cutree(ind_tree, k = k)


#test <- dist(t(cell_type_scores))
#test <- test.pam.k(ind.cor, kseq = 3:15, diss = TRUE, plot.results = FALSE, metric = "euclidean")

#test <- test.pam.k(ind.cor, kseq = 3:15, plot.results = FALSE, metric = "euclidean")
#boxplot(test$cl.width)
#k <- names(which.max(sapply(test$cl.width, mean)))
#groups <- test$mem[,k]

#cor.umap <- umap(ind.cor)
#plot(cor.umap$layout, col = pheno.col, pch = 16)

#test <- test.pam.k(cor.umap$layout, plot.results = FALSE)
#k <- names(which.max(sapply(test$cl.width, mean)))
#groups <- test$mem[,k]
```

The correlation among individuals is shown below 
along with their group assignments based on hierarchical 
clustering. 


```{r group_heat, fig.height = 7, fig.width = 8}
group.df <- data.frame("Group" = as.factor(groups))
ind.group.order <- names(groups)[order(groups)]

pheno.df <- data.frame("Phenotype_Score" = pheno.score)

#ind.group.order <- reorder_dendrogram(ind.cor, pheno.score)

pheatmap(ind.cor[ind.group.order, ind.group.order], 
    show_rownames = FALSE, show_colnames = FALSE, cluster_rows = FALSE, cluster_cols = FALSE,
    main = "Covariance of individuals by cell type score", annotation_col = group.df)

```

The distribution of phenotypes in each group is shown below.

```{r group_pheno, fig.height = 5, fig.width = 5}
group.idx <- lapply(1:k, function(x) names(groups)[which(groups == x)])
group.pheno <- lapply(group.idx, function(x) pheno.score[x])
names(group.pheno) <- paste0("group", 1:k)
group.order <- order(sapply(group.pheno, mean))

boxplot(group.pheno[group.order], main = "Phenotype Distribution by Group")
abline(h = 0)
```

The distributions of cell type scores in each group
is shown below.

```{r group_cell_types}
#collect cell type means per group
group.mats <- vector(mode = "list", length = k)
names(group.mats) <- paste("Group", 1:k)
for(i in 1:length(group.order)){
    group.mat <- t(cell_type_scores[,group.idx[[group.order[i]]]])
    mat.list <- lapply(1:ncol(group.mat), function(x) group.mat[,x])
    names(mat.list) <- colnames(group.mat)
    group.mats[[i]] <- mat.list
    }

plot.grouped.boxes(group.mats, print.vals = NA, plot.grouping = "inner")
```

A different view of these data are shown below. The
heat map shows the mean value for each cell type in 
each group.

```{r cell_type_heat, fig.width = 7, fig.height = 4}
group.means <- sapply(group.mats, function(x) sapply(x, mean))
mean.pheno <- sapply(group.pheno[group.order], mean)
names(mean.pheno) <- names(group.mats)
pheno.df <- data.frame("Phenotype" = mean.pheno)
pheatmap(group.means, cluster_cols = FALSE, annotation_col = pheno.df)
```

The following plot shows the individual scores for each
cell type ordered by the groups.

```{r, fig.width = 9, fig.height = 4}
pheatmap(cell_type_scores[,ind.group.order], cluster_cols = FALSE, 
    show_colnames = FALSE, scale = "row", annotation_col = group.df)
```

We are not saying anything about the physiology of the cells
in obese and non-obese animals. This is purely a compositional
statement. Beta cells stay constant as a proportion of the total
cells in the islets whereas alpha cells are proportionally higher 
in the obese animals.

```{r scratch, eval = FALSE}
load(here("Data", "DO", "QTLViewer_Geno_V10.Rdata"))


```